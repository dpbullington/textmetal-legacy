<?xml version="1.0" encoding="utf-8"?>

<!--
	Copyright ©2002-2014 Daniel Bullington (dpbullington@gmail.com)
	Distributed under the MIT license: http://www.opensource.org/licenses/mit-license.php
-->
<Template xmlns="http://www.textmetal.com/api/v6.0.0">

	<InvokeSourceStrategy src="${ObfuscationConfigFilePath}" alloc="true" var="obfuCfg" aqt-name="TextMetal.Framework.SourceModel.Primative.JsonSourceStrategy, TextMetal.Framework.SourceModel" />

	<OutputScope name="SSIS.cs.g" append="false">
<![CDATA[
	// start
]]>
	</OutputScope>

	<OutputScope name="${ObfuscationConfigFilePath}.g" append="false">
<![CDATA[
{
	"MaskFactor": 0.50,
	
	"NumericSign":
	{
		"HashMultiplier": 33, 
		"HashBucketSize": 1000000,
		"HashSeed": 5381
	},
	
	"TablesViews": [
]]>
	</OutputScope>

	<OutputScope name="Obfuscation_Triggers.g.sql">
<![CDATA[

SET NOCOUNT ON
GO


---------------------------------------------------------------------------------------------------------------------------------------------------------------
--	STRATEGY		DATA TYPE	DESCRIPTION
---------------------------------------------------------------------------------------------------------------------------------------------------------------
--	none			any			Returns un-obfuscated, original value.
--	substitution	string		Returns an alternate value using a hashed lookup into a dictionary.
--	shuffling		string		Returns an alternate value using a hashed shuffle of alphanumeric characters (while preserving other characters).
--	variance		numeric		Returns an alternate value within +/- (x%) of the original value.
--					temporal	Returns an alternate value within +/- (x%:365.25d) of the original value.
--	ciphering		string		Returns an alternate value that is a binary encryption of the original value.
--	defaulting		any			Returns an alternate value that is always null if NULL or the default value if NOT NULL.
--	masking			string		Returns an alternate value that is a +/- (%) mask of the original value.
---------------------------------------------------------------------------------------------------------------------------------------------------------------


USE [master]
GO


IF EXISTS (SELECT * FROM sysdatabases WHERE name = '${DataObfuscationProxyDatabaseName}')
BEGIN

	ALTER DATABASE [${DataObfuscationProxyDatabaseName}] SET SINGLE_USER WITH ROLLBACK IMMEDIATE
	
	DROP DATABASE [${DataObfuscationProxyDatabaseName}]
	
END
GO


CREATE DATABASE [${DataObfuscationProxyDatabaseName}]
GO


USE [${DataObfuscationProxyDatabaseName}]
GO


CREATE SCHEMA [DataObfuscation]
GO


-- template for custom dictionary
CREATE TABLE [DataObfuscation].[CrayonColorDictionary]
(
	[CrayonColorDictionaryKey] [int] IDENTITY(-1,1) NOT NULL,
	[CrayonColorDictionaryValue] [nvarchar](255) NOT NULL,
	
	CONSTRAINT [pk_CrayonColorDictionary] PRIMARY KEY
	(
		[CrayonColorDictionaryKey]
	),
	
	-- optional
	CONSTRAINT [uk_CrayonColorDictionary] UNIQUE
	(
		[CrayonColorDictionaryValue]
	)
)	
GO


CREATE TABLE [DataObfuscation].[FirstNameDictionary]
(
	[FirstNameDictionaryKey] [int] IDENTITY(-1,1) NOT NULL,
	[FirstNameDictionaryValue] [nvarchar](255) NOT NULL,
	
	CONSTRAINT [pk_FirstNameDictionary] PRIMARY KEY
	(
		[FirstNameDictionaryKey]
	),
	
	-- optional
	CONSTRAINT [uk_FirstNameDictionary] UNIQUE
	(
		[FirstNameDictionaryValue]
	)
)	
GO


CREATE TABLE [DataObfuscation].[LastNameDictionary]
(
	[LastNameDictionaryKey] [int] IDENTITY(-1,1) NOT NULL,
	[LastNameDictionaryValue] [nvarchar](255) NOT NULL,
	
	CONSTRAINT [pk_LastNameDictionary] PRIMARY KEY
	(
		[LastNameDictionaryKey]
	),
	
	-- optional
	CONSTRAINT [uk_LastNameDictionary] UNIQUE
	(
		[LastNameDictionaryValue]
	)
)	
GO


CREATE TABLE [DataObfuscation].[CityNameDictionary]
(
	[CityNameDictionaryKey] [int] IDENTITY(-1,1) NOT NULL,
	[CityNameDictionaryValue] [nvarchar](255) NOT NULL,
	
	CONSTRAINT [pk_CityNameDictionary] PRIMARY KEY
	(
		[CityNameDictionaryKey]
	),
	
	-- optional
	CONSTRAINT [uk_CityNameDictionary] UNIQUE
	(
		[CityNameDictionaryValue]
	)
)	
GO


CREATE TABLE [DataObfuscation].[StateNameDictionary]
(
	[StateNameDictionaryKey] [int] IDENTITY(-1,1) NOT NULL,
	[StateNameDictionaryValue] [nvarchar](255) NOT NULL,
	
	CONSTRAINT [pk_StateNameDictionary] PRIMARY KEY
	(
		[StateNameDictionaryKey]
	),
	
	-- optional
	CONSTRAINT [uk_StateNameDictionary] UNIQUE
	(
		[StateNameDictionaryValue]
	)
)	
GO


CREATE TABLE [DataObfuscation].[CountryNameDictionary]
(
	[CountryNameDictionaryKey] [int] IDENTITY(-1,1) NOT NULL,
	[CountryNameDictionaryValue] [nvarchar](255) NOT NULL,
	
	CONSTRAINT [pk_CountryNameDictionary] PRIMARY KEY
	(
		[CountryNameDictionaryKey]
	),
	
	-- optional
	CONSTRAINT [uk_CountryNameDictionary] UNIQUE
	(
		[CountryNameDictionaryValue]
	)
)	
GO


CREATE ASSEMBLY [TextMetal.Common.SqlServerClr]
AUTHORIZATION [dbo]
FROM
]]>
		<Include name="${argument_basedir}\TextMetal.Common.SqlServerClr.dll.txt" />
<![CDATA[WITH PERMISSION_SET = SAFE
GO


CREATE FUNCTION [DataObfuscation].[fn_GetCipher]
(
	@sharedSecret [nvarchar](MAX),
	@value [sql_variant]
)
RETURNS [sql_variant]
AS EXTERNAL NAME [TextMetal.Common.SqlServerClr].[TextMetal.Common.SqlServerClr.ScalarFunctions].[fn_GetCipher]
GO


CREATE FUNCTION [DataObfuscation].[fn_GetDefault]
(
	@isNullable [bit],
	@sqlType [nvarchar](64)
)
RETURNS [sql_variant]
AS EXTERNAL NAME [TextMetal.Common.SqlServerClr].[TextMetal.Common.SqlServerClr.ScalarFunctions].[fn_GetDefault]
GO


CREATE FUNCTION [DataObfuscation].[fn_GetHash]
(
	@hashMultiplier [bigint],
	@hashBucketSize [bigint],
	@hashSeed [bigint],
	@value [nvarchar](MAX)
)
RETURNS [bigint]
AS EXTERNAL NAME [TextMetal.Common.SqlServerClr].[TextMetal.Common.SqlServerClr.ScalarFunctions].[fn_GetHash]
GO


CREATE FUNCTION [DataObfuscation].[fn_GetMask]
(
	@maskFactor as [float],
	@value [sql_variant]
)
RETURNS [sql_variant]
AS EXTERNAL NAME [TextMetal.Common.SqlServerClr].[TextMetal.Common.SqlServerClr.ScalarFunctions].[fn_GetMask]
GO


CREATE FUNCTION [DataObfuscation].[fn_GetShuffle]
(
	@randomSeed [bigint],
	@value [sql_variant]
)
RETURNS [sql_variant]
AS EXTERNAL NAME [TextMetal.Common.SqlServerClr].[TextMetal.Common.SqlServerClr.ScalarFunctions].[fn_GetShuffle]
GO


CREATE FUNCTION [DataObfuscation].[fn_GetVariance]
(
	@varianceFactor as [float],
	@value [sql_variant]
)
RETURNS [sql_variant]
AS EXTERNAL NAME [TextMetal.Common.SqlServerClr].[TextMetal.Common.SqlServerClr.ScalarFunctions].[fn_GetVariance]
GO
]]>
	
	<ForEach in="Schemas" var-ct="_LoopCount" var-ix="_LoopIndex">
		<ForEach.Filter>
			<Ruby src="Script">
				<Script>!["db_accessadmin", "db_backupoperator", "db_datareader",
				"db_datawriter", "db_ddladmin", "db_denydatareader", "db_denydatawriter",
				"db_owner", "db_securityadmin", "sys",
				"INFORMATION_SCHEMA", "guest"].include?(textMetal.EvaluateToken.invoke("SchemaName"));</Script>
			</Ruby>	
		</ForEach.Filter>
		
		<ForEach.Body>
			<If>
				<If.Condition>
					<BinaryExpression operator="Ne">
						<BinaryExpression.LeftExpression>
							<Facet name="SchemaName" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Value type="System.String" data="dbo" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</If.Condition>
				<If.True>
<![CDATA[

CREATE SCHEMA [${SchemaName}]
GO
]]>
				</If.True>
				<If.False>
<![CDATA[

-- DO NOT CREATE SCHEMA [${SchemaName}]
]]>
				</If.False>
			</If>
			
			<ForEach in="Tables" var-ct="_LoopCount" var-ix="_LoopIndex">
				<ForEach.Filter>
				</ForEach.Filter>
				<ForEach.Body>
<![CDATA[

CREATE TABLE [${SchemaName}].[${TableName}]
(
]]>
				<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
					<ForEach.Sort>
						<Ascending>
							<Ascending.Compare>
								<Facet name="ColumnOrdinal" />
							</Ascending.Compare>
						</Ascending>
					</ForEach.Sort>
					<ForEach.Body>
						<![CDATA[	[${ColumnName}] [${ColumnSqlType}]${rb(`
	x = ""
	if ["binary", "char", "float", "nchar", "nvarchar", "varbinary", "varchar"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		x += "(" + (textMetal.EvaluateToken.invoke("ColumnSize") > 0 ? textMetal.EvaluateToken.invoke("ColumnSize").to_s() : "MAX") + ")"
	elsif ["decimal", "numeric"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		x += "(" + textMetal.EvaluateToken.invoke("ColumnPrecision").to_s() + ", " + textMetal.EvaluateToken.invoke("ColumnScale").to_s() + ")"
	else
		x += ""
	end
		
	if textMetal.EvaluateToken.invoke("ColumnIsIdentity")
		x += "" #" IDENTITY(1,1)"
	else
		x += ""
	end
	
	x
`)} ${rb(`textMetal.EvaluateToken.invoke("ColumnNullable") ? "" : "NOT "`)}NULL,]]>
							
						<If>
							<If.Condition>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="_LoopCount" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Facet name="_LoopIndex" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</If.Condition>
							<If.True>
<![CDATA[
]]>
							</If.True>
						</If>
					</ForEach.Body>
				</ForEach>
				
				
	<If>
		<If.Condition>
			<BinaryExpression operator="Ne">
				<BinaryExpression.LeftExpression>
					<Facet name="HasNoDefinedPrimaryKeyColumns" />
				</BinaryExpression.LeftExpression>
				<BinaryExpression.RightExpression>
					<Value type="System.Boolean" data="True" />
				</BinaryExpression.RightExpression>
			</BinaryExpression>
		</If.Condition>
		<If.True>
<![CDATA[

	CONSTRAINT [pk_${TableName}] PRIMARY KEY
	(
]]>
				<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
					<ForEach.Sort>
						<Ascending>
							<Ascending.Compare>
								<Facet name="ColumnOrdinal" />
							</Ascending.Compare>
						</Ascending>
					</ForEach.Sort>
					<ForEach.Filter>
						<BinaryExpression operator="Eq">
							<BinaryExpression.LeftExpression>
								<Facet name="ColumnIsPrimaryKey" />
							</BinaryExpression.LeftExpression>
							<BinaryExpression.RightExpression>
								<Value type="System.Boolean" data="True" />
							</BinaryExpression.RightExpression>
						</BinaryExpression>
					</ForEach.Filter>
					<ForEach.Body>
						<![CDATA[		[${ColumnName}]]]>
							
						<If>
							<If.Condition>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="_LoopCount" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Facet name="_LoopIndex" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</If.Condition>
							<If.True>
<![CDATA[,
]]>
							</If.True>
						</If>
					</ForEach.Body>
				</ForEach>
<![CDATA[
	)
]]>
		</If.True>
	</If>
<![CDATA[
)
GO


CREATE TRIGGER [${SchemaName}].[On${TableName}InsteadOfInsert] ON [${SchemaName}].[${TableName}] INSTEAD OF INSERT
AS
	BEGIN
		SET NOCOUNT ON;
		
		INSERT INTO [${SchemaName}].[${TableName}]
		(		
]]>
				<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
					<ForEach.Sort>
						<Ascending>
							<Ascending.Compare>
								<Facet name="ColumnOrdinal" />
							</Ascending.Compare>
						</Ascending>
					</ForEach.Sort>
					<ForEach.Filter>						
						<BinaryExpression operator="And">
							<BinaryExpression.LeftExpression>
								<BinaryExpression operator="Eq">
									<BinaryExpression.LeftExpression>
										<Facet name="ColumnIsComputed" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Value type="System.Boolean" data="False" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</BinaryExpression.LeftExpression>
							<BinaryExpression.RightExpression>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="ColumnSqlType" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Value type="System.String" data="timestamp" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</BinaryExpression.RightExpression>
						</BinaryExpression>
					</ForEach.Filter>
					<ForEach.Body>
						<![CDATA[			[${ColumnName}]]]>
							
						<If>
							<If.Condition>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="_LoopCount" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Facet name="_LoopIndex" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</If.Condition>
							<If.True>
<![CDATA[,
]]>
							</If.True>
						</If>
					</ForEach.Body>
				</ForEach>
<![CDATA[
		)
		SELECT
]]>		
				<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">							
					<ForEach.Sort>
						<Ascending>
							<Ascending.Compare>
								<Facet name="ColumnOrdinal" />
							</Ascending.Compare>
						</Ascending>
					</ForEach.Sort>
					<ForEach.Filter>
						<BinaryExpression operator="And">
							<BinaryExpression.LeftExpression>
								<BinaryExpression operator="Eq">
									<BinaryExpression.LeftExpression>
										<Facet name="ColumnIsComputed" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Value type="System.Boolean" data="False" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</BinaryExpression.LeftExpression>
							<BinaryExpression.RightExpression>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="ColumnSqlType" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Value type="System.String" data="timestamp" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</BinaryExpression.RightExpression>
						</BinaryExpression>
					</ForEach.Filter>
					<ForEach.Body>
	<If>
		<If.Condition>
			<Ruby src="Script">
				<Script>
<![CDATA[
	temp1 = ["text", "ntext", "image", "xml", "timestamp", "rowversion", "sql_variant", "geography", "hierarchyid", "geometry", "datetimeoffset"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"));
	temp2 = ["varchar", "nvarchar", "varbinary"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
	temp3 = textMetal.EvaluateToken.invoke("ColumnSize") <= 0
	temp4 = !(temp1 || (temp2 && temp3))
	
	#temp4
	
	true
]]>
				</Script>
			</Ruby>
		</If.Condition>
		<If.True>
<![CDATA[			CAST( ${rb(`
	#textMetal.DebuggerBreakpoint.invoke()
	obfuCfg = textMetal.EvaluateToken.invoke("obfuCfg")
	tblCfg = obfuCfg["TablesViews".to_clr_string()].select{|obj|
		obj["DatabaseName".to_clr_string()] == textMetal.EvaluateToken.invoke("DefaultDatabaseName") &&
		obj["SchemaName".to_clr_string()] == textMetal.EvaluateToken.invoke("SchemaName") &&
		obj["TableName".to_clr_string()] == textMetal.EvaluateToken.invoke("TableName") &&
		obj["ColumnName".to_clr_string()] == textMetal.EvaluateToken.invoke("ColumnName")
		}.first()
		
	numSgn = obfuCfg["NumericSign".to_clr_string()]
				
	if tblCfg.nil?
		"/* EXCLUDE_NO_CONFIG */ i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "]"
	else
		strategy = tblCfg["StrategyTag".to_clr_string()]
		
		case strategy.to_s()			
			when "substitution"
				dctCfg = tblCfg["Dictionary".to_clr_string()]
				
				"/* SUBSTITUTION */ (SELECT TOP 1 z.[" +
					dctCfg["ValueColumnName".to_clr_string()].to_s() + "] FROM [" +
					dctCfg["DatabaseName".to_clr_string()].to_s() + "].[" +
					dctCfg["SchemaName".to_clr_string()].to_s() + "].[" +
					dctCfg["TableName".to_clr_string()].to_s() + "] z WHERE z.[" +
					dctCfg["KeyColumnName".to_clr_string()].to_s() + "] = ([DataObfuscation].[fn_GetHash](" +
					tblCfg["HashMultiplier".to_clr_string()].to_s() + ", " +
					tblCfg["HashBucketSize".to_clr_string()].to_s() + ", " +
					tblCfg["HashSeed".to_clr_string()].to_s() + ", i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "])))"
			when "shuffling"
				"/* SHUFFLING */ ([DataObfuscation].[fn_GetShuffle]([DataObfuscation].[fn_GetHash](" +
					tblCfg["HashMultiplier".to_clr_string()].to_s() + ", " +
					tblCfg["HashBucketSize".to_clr_string()].to_s() + ", " +
					tblCfg["HashSeed".to_clr_string()].to_s() + ", i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "]), i.[" +
					textMetal.EvaluateToken.invoke("ColumnName") + "]))"
			when "variance"
				"/* VARIANCE */ ([DataObfuscation].[fn_GetVariance]((([DataObfuscation].[fn_GetHash](" +
					tblCfg["HashMultiplier".to_clr_string()].to_s() + ", " +
					tblCfg["HashBucketSize".to_clr_string()].to_s() + ", " +
					tblCfg["HashSeed".to_clr_string()].to_s() + ", CAST(i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "] AS [nvarchar](MAX))) * CASE WHEN ([DataObfuscation].[fn_GetHash](" +
					numSgn["HashMultiplier".to_clr_string()].to_s() + ", " +
					numSgn["HashBucketSize".to_clr_string()].to_s() + ", " +
					numSgn["HashSeed".to_clr_string()].to_s() + ", CAST(i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "] AS [nvarchar](MAX))) % 2) = 0 THEN 1 ELSE -1 END) / 100.0), i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "]))"
			when "ciphering"
				"/* CIPHERING */ (CASE WHEN i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "] IS NULL OR LEN(i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "]) = 0 THEN i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "] ELSE " +
					"[DataObfuscation].[fn_GetCipher]([DataObfuscation].[fn_GetHash](" +
					tblCfg["HashMultiplier".to_clr_string()].to_s() + ", " +
					tblCfg["HashBucketSize".to_clr_string()].to_s() + ", " +
					tblCfg["HashSeed".to_clr_string()].to_s() + ", i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "]), i.[" +
					textMetal.EvaluateToken.invoke("ColumnName") + "]) END)"
			when "defaulting"
				"/* DEFAULTING */ ([DataObfuscation].[fn_GetDefault](" + (textMetal.EvaluateToken.invoke("ColumnNullable") ? "1" : "0") + ", '" + textMetal.EvaluateToken.invoke("ColumnSqlType") + "'))"
			when "masking"
				maskFactor = obfuCfg["MaskFactor".to_clr_string()]
				
				"/* MASKING */ (CASE WHEN i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "] IS NULL OR LEN(i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "]) = 0 THEN i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "] ELSE " +
					"[DataObfuscation].[fn_GetMask](" + maskFactor.to_s() + ", i.[" +
					textMetal.EvaluateToken.invoke("ColumnName") + "]) END)"
			else #none
				"/* NONE */ (i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "])"
		end
	end
	`)} AS ${rb(`
	"[" + textMetal.EvaluateToken.invoke("ColumnSqlType") + "]" +	
	if ["binary", "char", "float", "nchar", "nvarchar", "varbinary", "varchar"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + (textMetal.EvaluateToken.invoke("ColumnSize") > 0 ? textMetal.EvaluateToken.invoke("ColumnSize").to_s() : "MAX") + ")"
	elsif ["decimal", "numeric"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + textMetal.EvaluateToken.invoke("ColumnPrecision").to_s() + ", " + textMetal.EvaluateToken.invoke("ColumnScale").to_s() + ")"
	else
		""
	end + " ) as [" + textMetal.EvaluateToken.invoke("ColumnName") + "]"
`)}]]>
		</If.True>
		
		<If.False>
<![CDATA[	CAST( /* EXCLUDE_BY_TYPE */ i.[${ColumnName}] AS [${ColumnSqlType}]${rb(`
	if ["binary", "char", "float", "nchar", "nvarchar", "varbinary", "varchar"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + (textMetal.EvaluateToken.invoke("ColumnSize") > 0 ? textMetal.EvaluateToken.invoke("ColumnSize").to_s() : "MAX") + ")"
	elsif ["decimal", "numeric"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + textMetal.EvaluateToken.invoke("ColumnPrecision").to_s() + ", " + textMetal.EvaluateToken.invoke("ColumnScale").to_s() + ")"
	else
		""
	end
`)} ) as [${ColumnName}]]]>
		</If.False>
	</If>
						<If>
							<If.Condition>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="_LoopCount" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Facet name="_LoopIndex" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</If.Condition>
							<If.True>
<![CDATA[,
]]>
							</If.True>
						</If>
					</ForEach.Body>

				</ForEach>
<![CDATA[
		FROM [inserted] i
	END
GO
]]>

	<OutputScope name="SSIS.cs.g" append="true">
<![CDATA[	config.Add(new Tuple<string, string>("${DefaultDatabaseName}", "[${SchemaName}].[${TableName}]"));
]]>
	</OutputScope>




			<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
				<ForEach.Sort>
					<Ascending>
						<Ascending.Compare>
							<Facet name="ColumnOrdinal" />
						</Ascending.Compare>
					</Ascending>
				</ForEach.Sort>
				<ForEach.Body>
				
<OutputScope name="${ObfuscationConfigFilePath}.g" append="true">
<![CDATA[
	{
		"DatabaseName": "${DefaultDatabaseName}",
		"SchemaName": "${SchemaName}",
		"TableName": "${TableName}",
		"ColumnName": "${ColumnName}",
		"StrategyTag": "none",
		"Dictionary":
		{
			"DatabaseName": "${DataObfuscationProxyDatabaseName}",
			"SchemaName": "DataObfuscation",
			"TableName": "CrayonColorDictionary",
			"KeyColumnName": "CrayonColorDictionaryKey",
			"ValueColumnName": "CrayonColorDictionaryValue"
		},
		"HashMultiplier": 33,
		"HashBucketSize": 120,
		"HashSeed": 5381
	},
]]>
</OutputScope>

					</ForEach.Body>

			</ForEach>





				</ForEach.Body>

			</ForEach>

		</ForEach.Body>
	</ForEach>
	</OutputScope>

	<OutputScope name="${ObfuscationConfigFilePath}.g" append="true">
<![CDATA[	]
}
]]>
	</OutputScope>

	<OutputScope name="SSIS.cs.g" append="true">
<![CDATA[
	// end
]]>
	</OutputScope>
</Template>