<?xml version="1.0" encoding="utf-8"?>

<!--
	Copyright ©2002-2014 Daniel Bullington (dpbullington@gmail.com)
	Distributed under the MIT license: http://www.opensource.org/licenses/mit-license.php
-->
<Template xmlns="http://www.textmetal.com/api/v6.0.0">

	<InvokeSourceStrategy src="${ObfuscationConfigFilePath}" alloc="true" var="obfuConf" aqt-name="TextMetal.Framework.SourceModel.Primative.JsonSourceStrategy, TextMetal.Framework.SourceModel" />

	<OutputScope name="${ObfuscationConfigFilePath}.g" append="false">
<![CDATA[
{
	"SignHash":
	{
		"Multiplier": 33, 
		"Size": 1000000,
		"Seed": 5381
	},

	"Dictionaries":
	[

		{
			"DictionaryId": "Null",

			"ObjectType": "*",
			"DatabaseName": "*",
			"SchemaName": "*",
			"ObjectName": "*",

			"KeyMemberType": "*",
			"KeyMemberName": "*",
			"ValueMemberType": "*",
			"ValueMemberName": "*",

			"RecordCount": 0
		},

		{
			"DictionaryId": "CrayonColor",

			"ObjectType": "Table",
			"DatabaseName": "Ox_Config",
			"SchemaName": "rev001",
			"ObjectName": "CrayonColorDictionary",

			"KeyMemberType": "Column",
			"KeyMemberName": "CrayonColorDictionaryKey",
			"ValueMemberType": "Column",
			"ValueMemberName": "CrayonColorDictionaryKey",

			"RecordCount": 121
		},

		{
			"DictionaryId": "FirstName",

			"ObjectType": "Table",
			"DatabaseName": "Ox_Config",
			"SchemaName": "rev001",
			"ObjectName": "FirstNameDictionary",

			"KeyMemberType": "Column",
			"KeyMemberName": "FirstNameDictionaryKey",
			"ValueMemberType": "Column",
			"ValueMemberName": "FirstNameDictionaryKey",

			"RecordCount": 5164
		},

		{
			"DictionaryId": "LastName",

			"ObjectType": "Table",
			"DatabaseName": "Ox_Config",
			"SchemaName": "rev001",
			"ObjectName": "LastNameDictionary",

			"KeyMemberType": "Column",
			"KeyMemberName": "LastNameDictionaryKey",
			"ValueMemberType": "Column",
			"ValueMemberName": "LastNameDictionaryKey",

			"RecordCount": 88800
		},

		{
			"DictionaryId": "CityName",

			"ObjectType": "Table",
			"DatabaseName": "Ox_Config",
			"SchemaName": "rev001",
			"ObjectName": "CityNameDictionary",

			"KeyMemberType": "Column",
			"KeyMemberName": "CityNameDictionaryKey",
			"ValueMemberType": "Column",
			"ValueMemberName": "CityNameDictionaryKey",

			"RecordCount": 0
		},

		{
			"DictionaryId": "StateName",

			"ObjectType": "Table",
			"DatabaseName": "Ox_Config",
			"SchemaName": "rev001",
			"ObjectName": "StateNameDictionary",

			"KeyMemberType": "Column",
			"KeyMemberName": "StateNameDictionaryKey",
			"ValueMemberType": "Column",
			"ValueMemberName": "StateNameDictionaryKey",

			"RecordCount": 0
		},

		{
			"DictionaryId": "CountryName",

			"ObjectType": "Table",
			"DatabaseName": "Ox_Config",
			"SchemaName": "rev001",
			"ObjectName": "CountryNameDictionary",

			"KeyMemberType": "Column",
			"KeyMemberName": "CountryNameDictionaryKey",
			"ValueMemberType": "Column",
			"ValueMemberName": "CountryNameDictionaryKey",

			"RecordCount": 0
		}

	],

	"Objects":
	[
]]>
	</OutputScope>

	<OutputScope name="Obfuscation_Triggers.g.sql">
<![CDATA[

SET NOCOUNT ON
GO


---------------------------------------------------------------------------------------------------------------------------------------------------------------
--	STRATEGY		DATA TYPE	DESCRIPTION
---------------------------------------------------------------------------------------------------------------------------------------------------------------
--	None			any			Returns un-obfuscated, original value.
--	Substitution	string		Returns an alternate value using a hashed lookup into a dictionary.
--	Shuffling		string		Returns an alternate value using a hashed shuffle of alphanumeric characters (while preserving other characters).
--	Variance		numeric		Returns an alternate value within +/- (x%) of the original value.
--					temporal	Returns an alternate value within +/- (x%:365.25d) of the original value.
--	Ciphering		string		Returns an alternate value that is a binary encryption of the original value.
--	Defaulting		any			Returns an alternate value that is always null if NULL or the default value if NOT NULL.
--	Masking			string		Returns an alternate value that is a +/- (%) mask of the original value.
---------------------------------------------------------------------------------------------------------------------------------------------------------------


USE [master]
GO


IF EXISTS (SELECT * FROM sysdatabases WHERE name = '${ObfuscationDestinationDatabaseName}')
BEGIN

	ALTER DATABASE [${ObfuscationDestinationDatabaseName}] SET SINGLE_USER WITH ROLLBACK IMMEDIATE
	
	DROP DATABASE [${ObfuscationDestinationDatabaseName}]
	
END
GO


CREATE DATABASE [${ObfuscationDestinationDatabaseName}]
GO


USE [${ObfuscationDestinationDatabaseName}]
GO


CREATE ASSEMBLY [TextMetal.Common.SqlServerClr]
AUTHORIZATION [dbo]
FROM
]]>
		<Include name="${Environment.ARGS.basedir}\TextMetal.Common.SqlServerClr.dll.txt" />
<![CDATA[WITH PERMISSION_SET = SAFE
GO


CREATE FUNCTION [dbo].[fn_GetCipher]
(
	@sharedSecret [nvarchar](MAX),
	@value [sql_variant]
)
RETURNS [sql_variant]
AS EXTERNAL NAME [TextMetal.Common.SqlServerClr].[TextMetal.Common.SqlServerClr.ScalarFunctions].[fn_GetCipher]
GO


CREATE FUNCTION [dbo].[fn_GetDefault]
(
	@isNullable [bit],
	@sqlType [nvarchar](64)
)
RETURNS [sql_variant]
AS EXTERNAL NAME [TextMetal.Common.SqlServerClr].[TextMetal.Common.SqlServerClr.ScalarFunctions].[fn_GetDefault]
GO


CREATE FUNCTION [dbo].[fn_GetHash]
(
	@hashMultiplier [bigint],
	@hashBucketSize [bigint],
	@hashSeed [bigint],
	@value [nvarchar](MAX)
)
RETURNS [bigint]
AS EXTERNAL NAME [TextMetal.Common.SqlServerClr].[TextMetal.Common.SqlServerClr.ScalarFunctions].[fn_GetHash]
GO


CREATE FUNCTION [dbo].[fn_GetMask]
(
	@maskFactor as [float],
	@value [sql_variant]
)
RETURNS [sql_variant]
AS EXTERNAL NAME [TextMetal.Common.SqlServerClr].[TextMetal.Common.SqlServerClr.ScalarFunctions].[fn_GetMask]
GO


CREATE FUNCTION [dbo].[fn_GetShuffle]
(
	@randomSeed [bigint],
	@value [sql_variant]
)
RETURNS [sql_variant]
AS EXTERNAL NAME [TextMetal.Common.SqlServerClr].[TextMetal.Common.SqlServerClr.ScalarFunctions].[fn_GetShuffle]
GO


CREATE FUNCTION [dbo].[fn_GetVariance]
(
	@varianceFactor as [float],
	@value [sql_variant]
)
RETURNS [sql_variant]
AS EXTERNAL NAME [TextMetal.Common.SqlServerClr].[TextMetal.Common.SqlServerClr.ScalarFunctions].[fn_GetVariance]
GO
]]>
	
	<ForEach in="Schemas" var-ct="_LoopCount" var-ix="_LoopIndex">
		<ForEach.Filter>
			<Ruby src="Script">
				<Script>!["db_accessadmin", "db_backupoperator", "db_datareader",
				"db_datawriter", "db_ddladmin", "db_denydatareader", "db_denydatawriter",
				"db_owner", "db_securityadmin", "sys",
				"INFORMATION_SCHEMA", "guest"].include?(textMetal.EvaluateToken.invoke("SchemaName"));</Script>
			</Ruby>	
		</ForEach.Filter>
		
		<ForEach.Body>
			<If>
				<If.Condition>
					<BinaryExpression operator="Ne">
						<BinaryExpression.LeftExpression>
							<Facet name="SchemaName" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Value type="System.String" data="dbo" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</If.Condition>
				<If.True>
<![CDATA[

CREATE SCHEMA [${SchemaName}]
GO
]]>
				</If.True>
				<If.False>
<![CDATA[

-- DO NOT CREATE SCHEMA [${SchemaName}]
]]>
				</If.False>
			</If>
			
			<ForEach in="Tables" var-ct="_LoopCount" var-ix="_LoopIndex">
				<ForEach.Filter>
				</ForEach.Filter>
				<ForEach.Body>
<![CDATA[

CREATE TABLE [${SchemaName}].[${TableName}]
(
]]>
				<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
					<ForEach.Sort>
						<Ascending>
							<Ascending.Compare>
								<Facet name="ColumnOrdinal" />
							</Ascending.Compare>
						</Ascending>
					</ForEach.Sort>
					<ForEach.Body>
						<![CDATA[	[${ColumnName}] [${rb(`
	if ["rowversion", "timestamp"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		type = "varbinary"
	else
		type = textMetal.EvaluateToken.invoke("ColumnSqlType")
	end
	
	type
	`)}]${rb(`
	x = ""
	if ["rowversion", "timestamp"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		x += "(8)"
	elsif ["nvarchar", "varbinary", "varchar"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		x += "(" + (textMetal.EvaluateToken.invoke("ColumnSize") > 0 ? textMetal.EvaluateToken.invoke("ColumnSize").to_s() : "MAX") + ")"
	elsif ["binary", "char", "nchar"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		x += "(" + (textMetal.EvaluateToken.invoke("ColumnSize") > 0 ? textMetal.EvaluateToken.invoke("ColumnSize").to_s() : "MAX") + ")"
	elsif ["float"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		x += "(" + textMetal.EvaluateToken.invoke("ColumnPrecision").to_s() + ")"
	elsif ["decimal", "numeric"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		x += "(" + textMetal.EvaluateToken.invoke("ColumnPrecision").to_s() + ", " + textMetal.EvaluateToken.invoke("ColumnScale").to_s() + ")"
	else
		x += ""
	end

		
	if textMetal.EvaluateToken.invoke("ColumnIsIdentity")
		x += "" #" IDENTITY(1,1)"
	else
		x += ""
	end
	
	x
`)} ${rb(`textMetal.EvaluateToken.invoke("ColumnNullable") ? "" : "NOT "`)}NULL,]]>
							
						<If>
							<If.Condition>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="_LoopCount" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Facet name="_LoopIndex" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</If.Condition>
							<If.True>
<![CDATA[
]]>
							</If.True>
						</If>
					</ForEach.Body>
				</ForEach>
				
				
	<If>
		<If.Condition>
			<BinaryExpression operator="Ne">
				<BinaryExpression.LeftExpression>
					<Facet name="HasNoDefinedPrimaryKeyColumns" />
				</BinaryExpression.LeftExpression>
				<BinaryExpression.RightExpression>
					<Value type="System.Boolean" data="True" />
				</BinaryExpression.RightExpression>
			</BinaryExpression>
		</If.Condition>
		<If.True>
<![CDATA[

	CONSTRAINT [pk_${TableName}] PRIMARY KEY
	(
]]>
				<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
					<ForEach.Sort>
						<Ascending>
							<Ascending.Compare>
								<Facet name="ColumnOrdinal" />
							</Ascending.Compare>
						</Ascending>
					</ForEach.Sort>
					<ForEach.Filter>
						<BinaryExpression operator="Eq">
							<BinaryExpression.LeftExpression>
								<Facet name="ColumnIsPrimaryKey" />
							</BinaryExpression.LeftExpression>
							<BinaryExpression.RightExpression>
								<Value type="System.Boolean" data="True" />
							</BinaryExpression.RightExpression>
						</BinaryExpression>
					</ForEach.Filter>
					<ForEach.Body>
						<![CDATA[		[${ColumnName}]]]>
							
						<If>
							<If.Condition>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="_LoopCount" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Facet name="_LoopIndex" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</If.Condition>
							<If.True>
<![CDATA[,
]]>
							</If.True>
						</If>
					</ForEach.Body>
				</ForEach>
<![CDATA[
	)
]]>
		</If.True>
	</If>
<![CDATA[
)
GO


CREATE TRIGGER [${SchemaName}].[On${TableName}InsteadOfInsert] ON [${SchemaName}].[${TableName}] INSTEAD OF INSERT
AS
	BEGIN
		SET NOCOUNT ON;
		
		INSERT INTO [${SchemaName}].[${TableName}]
		(		
]]>
				<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
					<ForEach.Sort>
						<Ascending>
							<Ascending.Compare>
								<Facet name="ColumnOrdinal" />
							</Ascending.Compare>
						</Ascending>
					</ForEach.Sort>
					<ForEach.Filter>						
						<BinaryExpression operator="And">
							<BinaryExpression.LeftExpression>
								<BinaryExpression operator="Eq">
									<BinaryExpression.LeftExpression>
										<Facet name="ColumnIsComputed" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Value type="System.Boolean" data="False" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</BinaryExpression.LeftExpression>
							<BinaryExpression.RightExpression>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="ColumnSqlType" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Value type="System.String" data="TODO___timestamp" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</BinaryExpression.RightExpression>
						</BinaryExpression>
					</ForEach.Filter>
					<ForEach.Body>
						<![CDATA[			[${ColumnName}]]]>
							
						<If>
							<If.Condition>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="_LoopCount" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Facet name="_LoopIndex" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</If.Condition>
							<If.True>
<![CDATA[,
]]>
							</If.True>
						</If>
					</ForEach.Body>
				</ForEach>
<![CDATA[
		)
		SELECT
]]>		
				<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">							
					<ForEach.Sort>
						<Ascending>
							<Ascending.Compare>
								<Facet name="ColumnOrdinal" />
							</Ascending.Compare>
						</Ascending>
					</ForEach.Sort>
					<ForEach.Filter>
						<BinaryExpression operator="And">
							<BinaryExpression.LeftExpression>
								<BinaryExpression operator="Eq">
									<BinaryExpression.LeftExpression>
										<Facet name="ColumnIsComputed" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Value type="System.Boolean" data="False" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</BinaryExpression.LeftExpression>
							<BinaryExpression.RightExpression>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="ColumnSqlType" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Value type="System.String" data="TODO___timestamp" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</BinaryExpression.RightExpression>
						</BinaryExpression>
					</ForEach.Filter>
					<ForEach.Body>
	<If>
		<If.Condition>
			<Ruby src="Script">
				<Script>
<![CDATA[
	#temp1 = ["text", "ntext", "image", "xml", "timestamp", "rowversion", "sql_variant", "geography", "hierarchyid", "geometry", "datetimeoffset"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"));
	#temp2 = ["varchar", "nvarchar", "varbinary"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
	#temp3 = textMetal.EvaluateToken.invoke("ColumnSize") <= 0
	#temp4 = !(temp1 || (temp2 && temp3))
	#temp4
	
	true
]]>
				</Script>
			</Ruby>
		</If.Condition>
		<If.True>
<![CDATA[			CAST( ${rb(`
	#textMetal.DebuggerBreakpoint.invoke()

	obfuConf = textMetal.EvaluateToken.invoke("obfuConf")
	raise "obfuConf==null" if obfuConf.nil?

	signHash = obfuConf["SignHash".to_clr_string()]
	raise "signHash==null" if signHash.nil?
		raise "signHash.Multiplier==null" if signHash["Multiplier".to_clr_string()].nil?
		raise "signHash.Size==null" if signHash["Size".to_clr_string()].nil?
		raise "signHash.Seed==null" if signHash["Seed".to_clr_string()].nil?


	tblVwObj = obfuConf["Objects".to_clr_string()].select{|obj|
		(obj["ObjectType".to_clr_string()] == "Table" || obj["ObjectType".to_clr_string()] == "View") &&
		obj["DatabaseName".to_clr_string()] == textMetal.EvaluateToken.invoke("DefaultDatabaseName") &&
		obj["SchemaName".to_clr_string()] == textMetal.EvaluateToken.invoke("SchemaName") &&
		obj["ObjectName".to_clr_string()] == textMetal.EvaluateToken.invoke("TableName")
		}.first()

	if !tblVwObj.nil?
		colObj = tblVwObj["Members".to_clr_string()].select{|obj|
			(obj["MemberType".to_clr_string()] == "Column") &&
			obj["MemberName".to_clr_string()] == textMetal.EvaluateToken.invoke("ColumnName")
			}.first()
	end


	if tblVwObj.nil? || colObj.nil?
		"/* EXCLUDE_NO_CONFIG */ i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "]"
	else
		obfuStrat = colObj["ObfuscationStrategy".to_clr_string()]
		raise "obfuStrat==null" if obfuStrat.nil?

		dictRef = colObj["DictionaryRef".to_clr_string()]
		raise "dictRef==null" if dictRef.nil?

		maskFactor = colObj["MaskFactor".to_clr_string()]
		raise "maskFactor==null" if maskFactor.nil?

		sharedSecret = colObj["SharedSecret".to_clr_string()]
		raise "sharedSecret==null" if sharedSecret.nil?

		valHash = colObj["ValueHash".to_clr_string()]
		raise "valHash==null" if valHash.nil?
			raise "valHash.Multiplier==null" if valHash["Multiplier".to_clr_string()].nil?
			raise "valHash.Size==null" if valHash["Size".to_clr_string()].nil?
			raise "valHash.Seed==null" if valHash["Seed".to_clr_string()].nil?

		dictObj = obfuConf["Dictionaries".to_clr_string()].select{|obj|
			dictRef == "Null" ||
			(obj["DictionaryId".to_clr_string()] == dictRef &&
			(obj["KeyMemberType".to_clr_string()] == "Column" && obj["ValueMemberType".to_clr_string()] == "Column") &&
			(obj["ObjectType".to_clr_string()] == "Table" || obj["ObjectType".to_clr_string()] == "View"))
			}.first()
		raise "dictObj==null" if dictObj.nil?
			raise "dictObj.ObjectType==null" if dictObj["ObjectType".to_clr_string()].nil?
			raise "dictObj.DatabaseName==null" if dictObj["DatabaseName".to_clr_string()].nil?
			raise "dictObj.SchemaName==null" if dictObj["SchemaName".to_clr_string()].nil?
			raise "dictObj.ObjectName==null" if dictObj["ObjectName".to_clr_string()].nil?
			raise "dictObj.KeyMemberType==null" if dictObj["KeyMemberType".to_clr_string()].nil?
			raise "dictObj.KeyMemberName==null" if dictObj["KeyMemberName".to_clr_string()].nil?
			raise "dictObj.ValueMemberType==null" if dictObj["ValueMemberType".to_clr_string()].nil?
			raise "dictObj.ValueMemberName==null" if dictObj["ValueMemberName".to_clr_string()].nil?


		case obfuStrat.to_s()
			when "Substitution"
				"/* SUBSTITUTION */ (SELECT TOP 1 z.[" +
					dictObj["ValueMemberName".to_clr_string()].to_s() + "] FROM [" +
					dictObj["DatabaseName".to_clr_string()].to_s() + "].[" +
					dictObj["SchemaName".to_clr_string()].to_s() + "].[" +
					dictObj["ObjectName".to_clr_string()].to_s() + "] z WHERE z.[" +
					dictObj["KeyMemberName".to_clr_string()].to_s() + "] = ([dbo].[fn_GetHash](" +
					valHash["Multiplier".to_clr_string()].to_s() + ", " +
					valHash["Size".to_clr_string()].to_s() + ", " +
					valHash["Seed".to_clr_string()].to_s() + ", i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "])))"
			when "Shuffling"
				"/* SHUFFLING */ ([dbo].[fn_GetShuffle]([dbo].[fn_GetHash](" +
					valHash["Multiplier".to_clr_string()].to_s() + ", " +
					valHash["Size".to_clr_string()].to_s() + ", " +
					valHash["Seed".to_clr_string()].to_s() + ", i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "]), i.[" +
					textMetal.EvaluateToken.invoke("ColumnName") + "]))"
			when "Variance"
				"/* VARIANCE */ ([dbo].[fn_GetVariance]((([dbo].[fn_GetHash](" +
					valHash["Multiplier".to_clr_string()].to_s() + ", " +
					valHash["Size".to_clr_string()].to_s() + ", " +
					valHash["Seed".to_clr_string()].to_s() + ", CAST(i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "] AS [nvarchar](MAX))) * CASE WHEN ([dbo].[fn_GetHash](" +
					signHash["Multiplier".to_clr_string()].to_s() + ", " +
					signHash["Size".to_clr_string()].to_s() + ", " +
					signHash["Seed".to_clr_string()].to_s() + ", CAST(i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "] AS [nvarchar](MAX))) % 2) = 0 THEN 1 ELSE -1 END) / 100.0), i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "]))"
			when "Ciphering"
				"/* CIPHERING */ (CASE WHEN i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "] IS NULL OR LEN(i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "]) = 0 THEN i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "] ELSE " +
					"[dbo].[fn_GetCipher]('" + sharedSecret.to_s() + "', i.[" +
					textMetal.EvaluateToken.invoke("ColumnName") + "]) END)"
			when "Defaulting"
				"/* DEFAULTING */ ([dbo].[fn_GetDefault](" + (textMetal.EvaluateToken.invoke("ColumnNullable") ? "1" : "0") + ", '" + textMetal.EvaluateToken.invoke("ColumnSqlType") + "'))"
			when "Masking"
				"/* MASKING */ (CASE WHEN i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "] IS NULL OR LEN(i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "]) = 0 THEN i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "] ELSE " +
					"[dbo].[fn_GetMask](" + maskFactor.to_s() + ", i.[" +
					textMetal.EvaluateToken.invoke("ColumnName") + "]) END)"
			when "None"
				"/* NONE */ (i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "])"
			else #default
				"/* EXCLUDE_UNKNOWN */ (i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "])"
		end
	end
	`)} AS [${rb(`
	if ["rowversion", "timestamp"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		type = "varbinary"
	else
		type = textMetal.EvaluateToken.invoke("ColumnSqlType")
	end
	
	type
	`)}]${rb(`
	x = ""
	if ["rowversion", "timestamp"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		x += "(8)"
	elsif ["nvarchar", "varbinary", "varchar"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + (textMetal.EvaluateToken.invoke("ColumnSize") > 0 ? textMetal.EvaluateToken.invoke("ColumnSize").to_s() : "MAX") + ")"
	elsif ["binary", "char", "nchar"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + (textMetal.EvaluateToken.invoke("ColumnSize") > 0 ? textMetal.EvaluateToken.invoke("ColumnSize").to_s() : "MAX") + ")"
	elsif ["float"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + textMetal.EvaluateToken.invoke("ColumnPrecision").to_s() + ")"
	elsif ["decimal", "numeric"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + textMetal.EvaluateToken.invoke("ColumnPrecision").to_s() + ", " + textMetal.EvaluateToken.invoke("ColumnScale").to_s() + ")"
	else
		""
	end + " ) as [" + textMetal.EvaluateToken.invoke("ColumnName") + "]"
`)}]]>
		</If.True>
		
		<If.False>
<![CDATA[	CAST( /* EXCLUDE_BY_TYPE */ i.[${ColumnName}] AS [${rb(`
	if ["rowversion", "timestamp"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		type = "varbinary"
	else
		type = textMetal.EvaluateToken.invoke("ColumnSqlType")
	end
	
	type
	`)}]${rb(`
	x = ""
	if ["rowversion", "timestamp"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		x += "(8)"
	elsif ["nvarchar", "varbinary", "varchar"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + (textMetal.EvaluateToken.invoke("ColumnSize") > 0 ? textMetal.EvaluateToken.invoke("ColumnSize").to_s() : "MAX") + ")"
	elsif ["binary", "char", "nchar"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + (textMetal.EvaluateToken.invoke("ColumnSize") > 0 ? textMetal.EvaluateToken.invoke("ColumnSize").to_s() : "MAX") + ")"
	elsif ["float"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + textMetal.EvaluateToken.invoke("ColumnPrecision").to_s() + ")"
	elsif ["decimal", "numeric"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + textMetal.EvaluateToken.invoke("ColumnPrecision").to_s() + ", " + textMetal.EvaluateToken.invoke("ColumnScale").to_s() + ")"
	else
		""
	end
`)} ) as [${ColumnName}]]]>
		</If.False>
	</If>
						<If>
							<If.Condition>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="_LoopCount" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Facet name="_LoopIndex" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</If.Condition>
							<If.True>
<![CDATA[,
]]>
							</If.True>
						</If>
					</ForEach.Body>

				</ForEach>
<![CDATA[
		FROM [inserted] i
	END
GO
]]>



<OutputScope name="${ObfuscationConfigFilePath}.g" append="true">
<![CDATA[
		{
			"ObjectType": "Table",
			"DatabaseName": "${DefaultDatabaseName}",
			"SchemaName": "${SchemaName}",
			"ObjectName": "${TableName}",

			"Members":
			[
]]>
			<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
				<ForEach.Sort>
					<Ascending>
						<Ascending.Compare>
							<Facet name="ColumnOrdinal" />
						</Ascending.Compare>
					</Ascending>
				</ForEach.Sort>
				<ForEach.Body>
<![CDATA[
				{
					"MemberType": "Column",
					"MemberName": "${ColumnName}",

					"ObfuscationStrategy": "None",
					"DictionaryRef": "Null",
					"MaskFactor": 0.50,
					"SharedSecret": "v0ofW8yRTonp3t9L7O7wTqewwccSz2B239v7vW631xP38UKd53BHm9bq0751572n",

					"ValueHash":
					{
						"Multiplier": 33, 
						"Size": 120,
						"Seed": 5381
					}
				},
]]>
					</ForEach.Body>
			</ForEach>
<![CDATA[
			]
		},
]]>
</OutputScope>







				</ForEach.Body>

			</ForEach>

		</ForEach.Body>
	</ForEach>
	</OutputScope>

	<OutputScope name="${ObfuscationConfigFilePath}.g" append="true">
<![CDATA[	]
}
]]>
	</OutputScope>
</Template>