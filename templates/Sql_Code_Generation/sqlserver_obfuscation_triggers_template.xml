<?xml version="1.0" encoding="utf-8"?>

<!--
	Copyright ©2002-2014 Daniel Bullington (dpbullington@gmail.com)
	Distributed under the MIT license: http://www.opensource.org/licenses/mit-license.php
-->
<Template xmlns="http://www.textmetal.com/api/v6.0.0">

	<InvokeSourceStrategy src="${ObfuscationConfigFilePath}" alloc="true" var="obfuConf" aqt-name="TextMetal.Framework.SourceModel.Primative.JsonSourceStrategy, TextMetal.Framework.SourceModel" />

	<OutputScope name="${ObfuscationConfigFilePath}.g" append="false">
<![CDATA[
{
	"MaskFactor": 0.50,
	
	"SignHash":
	{
		"Multiplier": 33, 
		"Size": 1000000,
		"Seed": 5381
	},
	
	"Objects": [
]]>
	</OutputScope>

	<OutputScope name="Obfuscation_Triggers.g.sql">
<![CDATA[

SET NOCOUNT ON
GO


---------------------------------------------------------------------------------------------------------------------------------------------------------------
--	STRATEGY		DATA TYPE	DESCRIPTION
---------------------------------------------------------------------------------------------------------------------------------------------------------------
--	none			any			Returns un-obfuscated, original value.
--	substitution	string		Returns an alternate value using a hashed lookup into a dictionary.
--	shuffling		string		Returns an alternate value using a hashed shuffle of alphanumeric characters (while preserving other characters).
--	variance		numeric		Returns an alternate value within +/- (x%) of the original value.
--					temporal	Returns an alternate value within +/- (x%:365.25d) of the original value.
--	ciphering		string		Returns an alternate value that is a binary encryption of the original value.
--	defaulting		any			Returns an alternate value that is always null if NULL or the default value if NOT NULL.
--	masking			string		Returns an alternate value that is a +/- (%) mask of the original value.
---------------------------------------------------------------------------------------------------------------------------------------------------------------


USE [master]
GO


IF EXISTS (SELECT * FROM sysdatabases WHERE name = '${ObfuscationDestinationDatabaseName}')
BEGIN

	ALTER DATABASE [${ObfuscationDestinationDatabaseName}] SET SINGLE_USER WITH ROLLBACK IMMEDIATE
	
	DROP DATABASE [${ObfuscationDestinationDatabaseName}]
	
END
GO


CREATE DATABASE [${ObfuscationDestinationDatabaseName}]
GO


USE [${ObfuscationDestinationDatabaseName}]
GO


CREATE SCHEMA [${ObfuscationSchemaName}]
GO


-- template for custom dictionary
CREATE TABLE [${ObfuscationSchemaName}].[CrayonColorDictionary]
(
	[CrayonColorDictionaryKey] [int] IDENTITY(-1,1) NOT NULL,
	[CrayonColorDictionaryValue] [nvarchar](255) NOT NULL,
	
	CONSTRAINT [pk_CrayonColorDictionary] PRIMARY KEY
	(
		[CrayonColorDictionaryKey]
	),
	
	-- optional
	CONSTRAINT [uk_CrayonColorDictionary] UNIQUE
	(
		[CrayonColorDictionaryValue]
	)
)	
GO


CREATE TABLE [${ObfuscationSchemaName}].[FirstNameDictionary]
(
	[FirstNameDictionaryKey] [int] IDENTITY(-1,1) NOT NULL,
	[FirstNameDictionaryValue] [nvarchar](255) NOT NULL,
	
	CONSTRAINT [pk_FirstNameDictionary] PRIMARY KEY
	(
		[FirstNameDictionaryKey]
	),
	
	-- optional
	CONSTRAINT [uk_FirstNameDictionary] UNIQUE
	(
		[FirstNameDictionaryValue]
	)
)	
GO


CREATE TABLE [${ObfuscationSchemaName}].[LastNameDictionary]
(
	[LastNameDictionaryKey] [int] IDENTITY(-1,1) NOT NULL,
	[LastNameDictionaryValue] [nvarchar](255) NOT NULL,
	
	CONSTRAINT [pk_LastNameDictionary] PRIMARY KEY
	(
		[LastNameDictionaryKey]
	),
	
	-- optional
	CONSTRAINT [uk_LastNameDictionary] UNIQUE
	(
		[LastNameDictionaryValue]
	)
)	
GO


CREATE TABLE [${ObfuscationSchemaName}].[CityNameDictionary]
(
	[CityNameDictionaryKey] [int] IDENTITY(-1,1) NOT NULL,
	[CityNameDictionaryValue] [nvarchar](255) NOT NULL,
	
	CONSTRAINT [pk_CityNameDictionary] PRIMARY KEY
	(
		[CityNameDictionaryKey]
	),
	
	-- optional
	CONSTRAINT [uk_CityNameDictionary] UNIQUE
	(
		[CityNameDictionaryValue]
	)
)	
GO


CREATE TABLE [${ObfuscationSchemaName}].[StateNameDictionary]
(
	[StateNameDictionaryKey] [int] IDENTITY(-1,1) NOT NULL,
	[StateNameDictionaryValue] [nvarchar](255) NOT NULL,
	
	CONSTRAINT [pk_StateNameDictionary] PRIMARY KEY
	(
		[StateNameDictionaryKey]
	),
	
	-- optional
	CONSTRAINT [uk_StateNameDictionary] UNIQUE
	(
		[StateNameDictionaryValue]
	)
)	
GO


CREATE TABLE [${ObfuscationSchemaName}].[CountryNameDictionary]
(
	[CountryNameDictionaryKey] [int] IDENTITY(-1,1) NOT NULL,
	[CountryNameDictionaryValue] [nvarchar](255) NOT NULL,
	
	CONSTRAINT [pk_CountryNameDictionary] PRIMARY KEY
	(
		[CountryNameDictionaryKey]
	),
	
	-- optional
	CONSTRAINT [uk_CountryNameDictionary] UNIQUE
	(
		[CountryNameDictionaryValue]
	)
)	
GO


CREATE ASSEMBLY [TextMetal.Common.SqlServerClr]
AUTHORIZATION [dbo]
FROM
]]>
		<Include name="${argument_basedir}\TextMetal.Common.SqlServerClr.dll.txt" />
<![CDATA[WITH PERMISSION_SET = SAFE
GO


CREATE FUNCTION [${ObfuscationSchemaName}].[fn_GetCipher]
(
	@sharedSecret [nvarchar](MAX),
	@value [sql_variant]
)
RETURNS [sql_variant]
AS EXTERNAL NAME [TextMetal.Common.SqlServerClr].[TextMetal.Common.SqlServerClr.ScalarFunctions].[fn_GetCipher]
GO


CREATE FUNCTION [${ObfuscationSchemaName}].[fn_GetDefault]
(
	@isNullable [bit],
	@sqlType [nvarchar](64)
)
RETURNS [sql_variant]
AS EXTERNAL NAME [TextMetal.Common.SqlServerClr].[TextMetal.Common.SqlServerClr.ScalarFunctions].[fn_GetDefault]
GO


CREATE FUNCTION [${ObfuscationSchemaName}].[fn_GetHash]
(
	@hashMultiplier [bigint],
	@hashBucketSize [bigint],
	@hashSeed [bigint],
	@value [nvarchar](MAX)
)
RETURNS [bigint]
AS EXTERNAL NAME [TextMetal.Common.SqlServerClr].[TextMetal.Common.SqlServerClr.ScalarFunctions].[fn_GetHash]
GO


CREATE FUNCTION [${ObfuscationSchemaName}].[fn_GetMask]
(
	@maskFactor as [float],
	@value [sql_variant]
)
RETURNS [sql_variant]
AS EXTERNAL NAME [TextMetal.Common.SqlServerClr].[TextMetal.Common.SqlServerClr.ScalarFunctions].[fn_GetMask]
GO


CREATE FUNCTION [${ObfuscationSchemaName}].[fn_GetShuffle]
(
	@randomSeed [bigint],
	@value [sql_variant]
)
RETURNS [sql_variant]
AS EXTERNAL NAME [TextMetal.Common.SqlServerClr].[TextMetal.Common.SqlServerClr.ScalarFunctions].[fn_GetShuffle]
GO


CREATE FUNCTION [${ObfuscationSchemaName}].[fn_GetVariance]
(
	@varianceFactor as [float],
	@value [sql_variant]
)
RETURNS [sql_variant]
AS EXTERNAL NAME [TextMetal.Common.SqlServerClr].[TextMetal.Common.SqlServerClr.ScalarFunctions].[fn_GetVariance]
GO
]]>
	
	<ForEach in="Schemas" var-ct="_LoopCount" var-ix="_LoopIndex">
		<ForEach.Filter>
			<Ruby src="Script">
				<Script>!["db_accessadmin", "db_backupoperator", "db_datareader",
				"db_datawriter", "db_ddladmin", "db_denydatareader", "db_denydatawriter",
				"db_owner", "db_securityadmin", "sys",
				"INFORMATION_SCHEMA", "guest"].include?(textMetal.EvaluateToken.invoke("SchemaName"));</Script>
			</Ruby>	
		</ForEach.Filter>
		
		<ForEach.Body>
			<If>
				<If.Condition>
					<BinaryExpression operator="Ne">
						<BinaryExpression.LeftExpression>
							<Facet name="SchemaName" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Value type="System.String" data="dbo" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</If.Condition>
				<If.True>
<![CDATA[

CREATE SCHEMA [${SchemaName}]
GO
]]>
				</If.True>
				<If.False>
<![CDATA[

-- DO NOT CREATE SCHEMA [${SchemaName}]
]]>
				</If.False>
			</If>
			
			<ForEach in="Tables" var-ct="_LoopCount" var-ix="_LoopIndex">
				<ForEach.Filter>
				</ForEach.Filter>
				<ForEach.Body>
<![CDATA[

CREATE TABLE [${SchemaName}].[${TableName}]
(
]]>
				<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
					<ForEach.Sort>
						<Ascending>
							<Ascending.Compare>
								<Facet name="ColumnOrdinal" />
							</Ascending.Compare>
						</Ascending>
					</ForEach.Sort>
					<ForEach.Body>
						<![CDATA[	[${ColumnName}] [${ColumnSqlType}]${rb(`
	x = ""
	if ["nvarchar", "varbinary", "varchar"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		x += "(" + (textMetal.EvaluateToken.invoke("ColumnSize") > 0 ? textMetal.EvaluateToken.invoke("ColumnSize").to_s() : "MAX") + ")"
	elsif ["binary", "char", "nchar"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		x += "(" + (textMetal.EvaluateToken.invoke("ColumnSize") > 0 ? textMetal.EvaluateToken.invoke("ColumnSize").to_s() : "MAX") + ")"
	elsif ["float"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		x += "(" + textMetal.EvaluateToken.invoke("ColumnPrecision").to_s() + ")"
	elsif ["decimal", "numeric"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		x += "(" + textMetal.EvaluateToken.invoke("ColumnPrecision").to_s() + ", " + textMetal.EvaluateToken.invoke("ColumnScale").to_s() + ")"
	else
		x += ""
	end
		
	if textMetal.EvaluateToken.invoke("ColumnIsIdentity")
		x += "" #" IDENTITY(1,1)"
	else
		x += ""
	end
	
	x
`)} ${rb(`textMetal.EvaluateToken.invoke("ColumnNullable") ? "" : "NOT "`)}NULL,]]>
							
						<If>
							<If.Condition>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="_LoopCount" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Facet name="_LoopIndex" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</If.Condition>
							<If.True>
<![CDATA[
]]>
							</If.True>
						</If>
					</ForEach.Body>
				</ForEach>
				
				
	<If>
		<If.Condition>
			<BinaryExpression operator="Ne">
				<BinaryExpression.LeftExpression>
					<Facet name="HasNoDefinedPrimaryKeyColumns" />
				</BinaryExpression.LeftExpression>
				<BinaryExpression.RightExpression>
					<Value type="System.Boolean" data="True" />
				</BinaryExpression.RightExpression>
			</BinaryExpression>
		</If.Condition>
		<If.True>
<![CDATA[

	CONSTRAINT [pk_${TableName}] PRIMARY KEY
	(
]]>
				<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
					<ForEach.Sort>
						<Ascending>
							<Ascending.Compare>
								<Facet name="ColumnOrdinal" />
							</Ascending.Compare>
						</Ascending>
					</ForEach.Sort>
					<ForEach.Filter>
						<BinaryExpression operator="Eq">
							<BinaryExpression.LeftExpression>
								<Facet name="ColumnIsPrimaryKey" />
							</BinaryExpression.LeftExpression>
							<BinaryExpression.RightExpression>
								<Value type="System.Boolean" data="True" />
							</BinaryExpression.RightExpression>
						</BinaryExpression>
					</ForEach.Filter>
					<ForEach.Body>
						<![CDATA[		[${ColumnName}]]]>
							
						<If>
							<If.Condition>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="_LoopCount" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Facet name="_LoopIndex" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</If.Condition>
							<If.True>
<![CDATA[,
]]>
							</If.True>
						</If>
					</ForEach.Body>
				</ForEach>
<![CDATA[
	)
]]>
		</If.True>
	</If>
<![CDATA[
)
GO


CREATE TRIGGER [${SchemaName}].[On${TableName}InsteadOfInsert] ON [${SchemaName}].[${TableName}] INSTEAD OF INSERT
AS
	BEGIN
		SET NOCOUNT ON;
		
		INSERT INTO [${SchemaName}].[${TableName}]
		(		
]]>
				<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
					<ForEach.Sort>
						<Ascending>
							<Ascending.Compare>
								<Facet name="ColumnOrdinal" />
							</Ascending.Compare>
						</Ascending>
					</ForEach.Sort>
					<ForEach.Filter>						
						<BinaryExpression operator="And">
							<BinaryExpression.LeftExpression>
								<BinaryExpression operator="Eq">
									<BinaryExpression.LeftExpression>
										<Facet name="ColumnIsComputed" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Value type="System.Boolean" data="False" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</BinaryExpression.LeftExpression>
							<BinaryExpression.RightExpression>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="ColumnSqlType" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Value type="System.String" data="timestamp" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</BinaryExpression.RightExpression>
						</BinaryExpression>
					</ForEach.Filter>
					<ForEach.Body>
						<![CDATA[			[${ColumnName}]]]>
							
						<If>
							<If.Condition>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="_LoopCount" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Facet name="_LoopIndex" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</If.Condition>
							<If.True>
<![CDATA[,
]]>
							</If.True>
						</If>
					</ForEach.Body>
				</ForEach>
<![CDATA[
		)
		SELECT
]]>		
				<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">							
					<ForEach.Sort>
						<Ascending>
							<Ascending.Compare>
								<Facet name="ColumnOrdinal" />
							</Ascending.Compare>
						</Ascending>
					</ForEach.Sort>
					<ForEach.Filter>
						<BinaryExpression operator="And">
							<BinaryExpression.LeftExpression>
								<BinaryExpression operator="Eq">
									<BinaryExpression.LeftExpression>
										<Facet name="ColumnIsComputed" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Value type="System.Boolean" data="False" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</BinaryExpression.LeftExpression>
							<BinaryExpression.RightExpression>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="ColumnSqlType" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Value type="System.String" data="timestamp" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</BinaryExpression.RightExpression>
						</BinaryExpression>
					</ForEach.Filter>
					<ForEach.Body>
	<If>
		<If.Condition>
			<Ruby src="Script">
				<Script>
<![CDATA[
	#temp1 = ["text", "ntext", "image", "xml", "timestamp", "rowversion", "sql_variant", "geography", "hierarchyid", "geometry", "datetimeoffset"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"));
	#temp2 = ["varchar", "nvarchar", "varbinary"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
	#temp3 = textMetal.EvaluateToken.invoke("ColumnSize") <= 0
	#temp4 = !(temp1 || (temp2 && temp3))
	#temp4
	
	true
]]>
				</Script>
			</Ruby>
		</If.Condition>
		<If.True>
<![CDATA[			CAST( ${rb(`
	#textMetal.DebuggerBreakpoint.invoke()

	obfuConf = textMetal.EvaluateToken.invoke("obfuConf")
	raise "obfuConf==null" if obfuConf.nil?

	maskFactor = obfuConf["MaskFactor".to_clr_string()]
	raise "maskFactor==null" if maskFactor.nil?

	signHash = obfuConf["SignHash".to_clr_string()]
	raise "signHash==null" if signHash.nil?
		raise "signHash.Multiplier==null" if signHash["Multiplier".to_clr_string()].nil?
		raise "signHash.Size==null" if signHash["Size".to_clr_string()].nil?
		raise "signHash.Seed==null" if signHash["Seed".to_clr_string()].nil?


	tblVwObj = obfuConf["Objects".to_clr_string()].select{|obj|
		(obj["Source".to_clr_string()]["ObjectType".to_clr_string()] == "Table" || obj["Source".to_clr_string()]["ObjectType".to_clr_string()] == "View") &&
		obj["Source".to_clr_string()]["DatabaseName".to_clr_string()] == textMetal.EvaluateToken.invoke("DefaultDatabaseName") &&
		obj["Source".to_clr_string()]["SchemaName".to_clr_string()] == textMetal.EvaluateToken.invoke("SchemaName") &&
		obj["Source".to_clr_string()]["ObjectName".to_clr_string()] == textMetal.EvaluateToken.invoke("TableName")
		}.first()

	if !tblVwObj.nil?
		colObj = tblVwObj["Members".to_clr_string()].select{|obj|
			(obj["MemberType".to_clr_string()] == "Column") &&
			obj["MemberName".to_clr_string()] == textMetal.EvaluateToken.invoke("ColumnName")
			}.first()
	end


	if tblVwObj.nil? || colObj.nil?
		"/* EXCLUDE_NO_CONFIG */ i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "]"
	else
		obfuStrat = colObj["ObfuscationStrategy".to_clr_string()]
		raise "obfuStrat==null" if obfuStrat.nil?

		dictRef = colObj["DictionaryRef".to_clr_string()]
		raise "dictRef==null" if dictRef.nil?

		valHash = colObj["ValueHash".to_clr_string()]
		raise "valHash==null" if valHash.nil?
			raise "valHash.Multiplier==null" if valHash["Multiplier".to_clr_string()].nil?
			raise "valHash.Size==null" if valHash["Size".to_clr_string()].nil?
			raise "valHash.Seed==null" if valHash["Seed".to_clr_string()].nil?

		dictObj = obfuConf["Dictionaries".to_clr_string()].select{|obj|			
			obj["DictionaryType".to_clr_string()] == "External" &&
			obj["DictionaryId".to_clr_string()] == dictRef &&

			!obj["External".to_clr_string()].nil? &&
			(obj["External".to_clr_string()]["KeyMemberType".to_clr_string()] == "Column" && obj["External".to_clr_string()]["ValueMemberType".to_clr_string()] == "Column") &&
			!obj["External".to_clr_string()]["Source".to_clr_string()].nil? &&
			(obj["External".to_clr_string()]["Source".to_clr_string()]["ObjectType".to_clr_string()] == "Table" || obj["External".to_clr_string()]["Source".to_clr_string()]["ObjectType".to_clr_string()] == "View")
			}.first()
		raise "dictObj==null" if dictObj.nil?

		dictExt = dictObj["External".to_clr_string()]
		raise "dictExt==null" if dictExt.nil?
			raise "dictExt.KeyMemberType==null" if dictExt["KeyMemberType".to_clr_string()].nil?
			raise "dictExt.KeyMemberName==null" if dictExt["KeyMemberName".to_clr_string()].nil?
			raise "dictExt.ValueMemberType==null" if dictExt["ValueMemberType".to_clr_string()].nil?
			raise "dictExt.ValueMemberName==null" if dictExt["ValueMemberName".to_clr_string()].nil?

		dictExtSrc = dictExt["Source".to_clr_string()]
		raise "dictExtSrc==null" if dictExtSrc.nil?
			raise "dictExtSrc.ObjectType==null" if dictExtSrc["ObjectType".to_clr_string()].nil?
			raise "dictExtSrc.DatabaseName==null" if dictExtSrc["DatabaseName".to_clr_string()].nil?
			raise "dictExtSrc.SchemaName==null" if dictExtSrc["SchemaName".to_clr_string()].nil?
			raise "dictExtSrc.ObjectName==null" if dictExtSrc["ObjectName".to_clr_string()].nil?


		case obfuStrat.to_s()
			when "Substitution"
				"/* SUBSTITUTION */ (SELECT TOP 1 z.[" +
					dictExt["ValueMemberName".to_clr_string()].to_s() + "] FROM [" +
					dictExtSrc["DatabaseName".to_clr_string()].to_s() + "].[" +
					dictExtSrc["SchemaName".to_clr_string()].to_s() + "].[" +
					dictExtSrc["ObjectName".to_clr_string()].to_s() + "] z WHERE z.[" +
					dictExt["KeyMemberName".to_clr_string()].to_s() + "] = ([" + textMetal.EvaluateToken.invoke("ObfuscationSchemaName") + "].[fn_GetHash](" +
					valHash["Multiplier".to_clr_string()].to_s() + ", " +
					valHash["Size".to_clr_string()].to_s() + ", " +
					valHash["Seed".to_clr_string()].to_s() + ", i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "])))"
			when "Shuffling"
				"/* SHUFFLING */ ([" + textMetal.EvaluateToken.invoke("ObfuscationSchemaName") + "].[fn_GetShuffle]([" + textMetal.EvaluateToken.invoke("ObfuscationSchemaName") + "].[fn_GetHash](" +
					valHash["Multiplier".to_clr_string()].to_s() + ", " +
					valHash["Size".to_clr_string()].to_s() + ", " +
					valHash["Seed".to_clr_string()].to_s() + ", i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "]), i.[" +
					textMetal.EvaluateToken.invoke("ColumnName") + "]))"
			when "Variance"
				"/* VARIANCE */ ([" + textMetal.EvaluateToken.invoke("ObfuscationSchemaName") + "].[fn_GetVariance]((([" + textMetal.EvaluateToken.invoke("ObfuscationSchemaName") + "].[fn_GetHash](" +
					valHash["Multiplier".to_clr_string()].to_s() + ", " +
					valHash["Size".to_clr_string()].to_s() + ", " +
					valHash["Seed".to_clr_string()].to_s() + ", CAST(i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "] AS [nvarchar](MAX))) * CASE WHEN ([" + textMetal.EvaluateToken.invoke("ObfuscationSchemaName") + "].[fn_GetHash](" +
					signHash["Multiplier".to_clr_string()].to_s() + ", " +
					signHash["Size".to_clr_string()].to_s() + ", " +
					signHash["Seed".to_clr_string()].to_s() + ", CAST(i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "] AS [nvarchar](MAX))) % 2) = 0 THEN 1 ELSE -1 END) / 100.0), i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "]))"
			when "Ciphering"
				"/* CIPHERING */ (CASE WHEN i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "] IS NULL OR LEN(i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "]) = 0 THEN i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "] ELSE " +
					"[" + textMetal.EvaluateToken.invoke("ObfuscationSchemaName") + "].[fn_GetCipher]([" + textMetal.EvaluateToken.invoke("ObfuscationSchemaName") + "].[fn_GetHash](" +
					valHash["Multiplier".to_clr_string()].to_s() + ", " +
					valHash["Size".to_clr_string()].to_s() + ", " +
					valHash["Seed".to_clr_string()].to_s() + ", i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "]), i.[" +
					textMetal.EvaluateToken.invoke("ColumnName") + "]) END)"
			when "Defaulting"
				"/* DEFAULTING */ ([" + textMetal.EvaluateToken.invoke("ObfuscationSchemaName") + "].[fn_GetDefault](" + (textMetal.EvaluateToken.invoke("ColumnNullable") ? "1" : "0") + ", '" + textMetal.EvaluateToken.invoke("ColumnSqlType") + "'))"
			when "Masking"
				"/* MASKING */ (CASE WHEN i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "] IS NULL OR LEN(i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "]) = 0 THEN i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "] ELSE " +
					"[" + textMetal.EvaluateToken.invoke("ObfuscationSchemaName") + "].[fn_GetMask](" + maskFactor.to_s() + ", i.[" +
					textMetal.EvaluateToken.invoke("ColumnName") + "]) END)"
			when "None"
				"/* NONE */ (i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "])"
			else #default
				"/* EXCLUDE_UNKNOWN */ (i.[" + textMetal.EvaluateToken.invoke("ColumnName") + "])"
		end
	end
	`)} AS ${rb(`
	"[" + textMetal.EvaluateToken.invoke("ColumnSqlType") + "]" +
	if ["nvarchar", "varbinary", "varchar"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + (textMetal.EvaluateToken.invoke("ColumnSize") > 0 ? textMetal.EvaluateToken.invoke("ColumnSize").to_s() : "MAX") + ")"
	elsif ["binary", "char", "nchar"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + (textMetal.EvaluateToken.invoke("ColumnSize") > 0 ? textMetal.EvaluateToken.invoke("ColumnSize").to_s() : "MAX") + ")"
	elsif ["float"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + textMetal.EvaluateToken.invoke("ColumnPrecision").to_s() + ")"
	elsif ["decimal", "numeric"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + textMetal.EvaluateToken.invoke("ColumnPrecision").to_s() + ", " + textMetal.EvaluateToken.invoke("ColumnScale").to_s() + ")"
	else
		""
	end + " ) as [" + textMetal.EvaluateToken.invoke("ColumnName") + "]"
`)}]]>
		</If.True>
		
		<If.False>
<![CDATA[	CAST( /* EXCLUDE_BY_TYPE */ i.[${ColumnName}] AS [${ColumnSqlType}]${rb(`
	if ["nvarchar", "varbinary", "varchar"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + (textMetal.EvaluateToken.invoke("ColumnSize") > 0 ? textMetal.EvaluateToken.invoke("ColumnSize").to_s() : "MAX") + ")"
	elsif ["binary", "char", "nchar"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + (textMetal.EvaluateToken.invoke("ColumnSize") > 0 ? textMetal.EvaluateToken.invoke("ColumnSize").to_s() : "MAX") + ")"
	elsif ["float"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + textMetal.EvaluateToken.invoke("ColumnPrecision").to_s() + ")"
	elsif ["decimal", "numeric"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"(" + textMetal.EvaluateToken.invoke("ColumnPrecision").to_s() + ", " + textMetal.EvaluateToken.invoke("ColumnScale").to_s() + ")"
	else
		""
	end
`)} ) as [${ColumnName}]]]>
		</If.False>
	</If>
						<If>
							<If.Condition>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="_LoopCount" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Facet name="_LoopIndex" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</If.Condition>
							<If.True>
<![CDATA[,
]]>
							</If.True>
						</If>
					</ForEach.Body>

				</ForEach>
<![CDATA[
		FROM [inserted] i
	END
GO
]]>

			<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
				<ForEach.Sort>
					<Ascending>
						<Ascending.Compare>
							<Facet name="ColumnOrdinal" />
						</Ascending.Compare>
					</Ascending>
				</ForEach.Sort>
				<ForEach.Body>
				
<OutputScope name="${ObfuscationConfigFilePath}.g" append="true">
<![CDATA[
	{
		"ObjectType": "Table",
		"ObfuscationStrategy": "None",
		"DictionaryType": "External",
		
		"ObjectSource":
		{
			"DatabaseName": "${DefaultDatabaseName}",
			"SchemaName": "${SchemaName}",
			"ObjectName": "${TableName}",
			"MemberName": "${ColumnName}"
		},
		
		"DictionarySource":
		{
			"DatabaseName": "${ObfuscationDestinationDatabaseName}",
			"SchemaName": "${ObfuscationSchemaName}",
			"ObjectName": "CrayonColorDictionary",
			"MemberName": "CrayonColorDictionary{0}",

			"KeyMemberName": "CrayonColorDictionaryKey",
			"ValueMemberName": "CrayonColorDictionaryValue"
		},

		"ValueHash":
		{
			"Multiplier": 33, 
			"Size": 120,
			"Seed": 5381
		}
	},
]]>
</OutputScope>

					</ForEach.Body>

			</ForEach>





				</ForEach.Body>

			</ForEach>

		</ForEach.Body>
	</ForEach>
	</OutputScope>

	<OutputScope name="${ObfuscationConfigFilePath}.g" append="true">
<![CDATA[	]
}
]]>
	</OutputScope>
</Template>