<?xml version="1.0" encoding="utf-8"?>

<!--
	Copyright ©2002-2014 Daniel Bullington (dpbullington@gmail.com)
	Distributed under the MIT license: http://www.opensource.org/licenses/mit-license.php
-->
<Template xmlns="http://www.textmetal.com/api/v5.0.0">

	<OutputScope name="DM.g.sql">

<![CDATA[

USE [master]
GO


IF EXISTS (SELECT * FROM sysdatabases WHERE name = '${DataObfuscationProxyCatalogName}')
BEGIN

	ALTER DATABASE [${DataObfuscationProxyCatalogName}] SET SINGLE_USER WITH ROLLBACK IMMEDIATE
	
	DROP DATABASE [${DataObfuscationProxyCatalogName}]
	
END
GO


CREATE DATABASE [${DataObfuscationProxyCatalogName}]
GO


USE [${DataObfuscationProxyCatalogName}]
GO


CREATE SCHEMA [DataObfuscation]
GO


/*CREATE TABLE [DataObfuscation].[xxxDictionary]
(
	[xxxDictionaryKey] [int] IDENTITY(1,1) NOT NULL,
	[xxxDictionaryValue] [nvarchar](255) NOT NULL,
	
	CONSTRAINT [pk_xxxDictionary] PRIMARY KEY
	(
		[xxxDictionaryKey]
	),
	
	CONSTRAINT [uk_xxxDictionary] UNIQUE
	(
		[xxxDictionaryValue]
	)
)	
GO*/


CREATE VIEW [DataObfuscation].[Associative]
AS
-- TODO: need to implement this based on your custom needs (using [DataObfuscation].[xxxDictionary] if so inclined)
SELECT -1000 as [DictionaryId], 1 as [Key], 'apple' as [Value]
UNION
SELECT -1000 as [DictionaryId], 2 as [Key], 'orange' as [Value]
UNION
SELECT -1000 as [DictionaryId], 3 as [Key], 'lemon' as [Value]
UNION
SELECT -1000 as [DictionaryId], 4 as [Key], 'lime' as [Value]
UNION
SELECT -1000 as [DictionaryId], 5 as [Key], 'grape' as [Value]
GO


CREATE TABLE [DataObfuscation].[Dictionary]
(
	[DictionaryId] [int] NOT NULL,
	[DictionaryName] [nvarchar](64) NOT NULL,
	
	[HashMultiplier] [bigint] NOT NULL,
	[HashBucketSize] [int] NOT NULL,
	[HashSeed] [bigint] NOT NULL,
	
	CONSTRAINT [pk_Dictionary] PRIMARY KEY
	(
		[DictionaryId]
	),
	
	CONSTRAINT [uk_Dictionary] UNIQUE
	(
		[DictionaryName]
	)
)	
GO


INSERT INTO [DataObfuscation].[Dictionary] VALUES (-1000, 'TextMetal Fruit Dictionary', 33, 5, 5381)
GO


CREATE TABLE [DataObfuscation].[Strategy]
(
	[StrategyId] [int] NOT NULL,
	[StrategyName] [nvarchar](64) NOT NULL,
	[StrategyDesc] [nvarchar](1023) NOT NULL,

	CONSTRAINT [pk_Strategy] PRIMARY KEY
	(
		[StrategyId]
	),
	
	CONSTRAINT [uk_Strategy] UNIQUE
	(
		[StrategyName]
	)
)	
GO


CREATE TABLE [DataObfuscation].[StoredProcedureParameterConfig]
(
	[StoredProcedureParameterConfigId] [int] IDENTITY(1,1) NOT NULL,

	[CatalogName] [nvarchar](64) NOT NULL, -- skimping here to prevent index warning exceed 900 bytes
	[SchemaName] [nvarchar](128) NOT NULL,
	[ProcedureName] [nvarchar](128) NOT NULL,
	[ParameterName] [nvarchar](128) NOT NULL, -- output paramters only
	
	[StrategyId] [int] NOT NULL,
	
	[DictionaryId] [int] NULL,

	CONSTRAINT [pk_StoredProcedureParameterConfig] PRIMARY KEY
	(
		[StoredProcedureParameterConfigId]
	),
	
	CONSTRAINT [uk_StoredProcedureParameterConfig] UNIQUE
	(
		[CatalogName],
		[SchemaName],
		[ProcedureName],
		[ParameterName]
	),
	
	CONSTRAINT [fk_StoredProcedureParameterConfig_Strategy] FOREIGN KEY
	(
		[StrategyId]
	)
	REFERENCES [DataObfuscation].[Strategy]
	(
		[StrategyId]
	),
	
	CONSTRAINT [fk_StoredProcedureParameterConfig_Dictionary] FOREIGN KEY
	(
		[DictionaryId]
	)
	REFERENCES [DataObfuscation].[Dictionary]
	(
		[DictionaryId]
	)
)	
GO


CREATE TABLE [DataObfuscation].[StoredProcedureColumnConfig]
(
	[StoredProcedureColumnConfigId] [int] IDENTITY(1,1) NOT NULL,

	[CatalogName] [nvarchar](64) NOT NULL, -- skimping here to prevent index warning exceed 900 bytes
	[SchemaName] [nvarchar](128) NOT NULL,
	[ProcedureName] [nvarchar](128) NOT NULL,
	[ColumnName] [nvarchar](128) NOT NULL, -- output resultset columns only
	
	[StrategyId] [int] NOT NULL,
	
	[DictionaryId] [int] NULL,

	CONSTRAINT [pk_StoredProcedureColumnConfig] PRIMARY KEY
	(
		[StoredProcedureColumnConfigId]
	),
	
	CONSTRAINT [uk_StoredProcedureColumnConfig] UNIQUE
	(
		[CatalogName],
		[SchemaName],
		[ProcedureName],
		[ColumnName]
	),
	
	CONSTRAINT [fk_StoredProcedureColumnConfig_Strategy] FOREIGN KEY
	(
		[StrategyId]
	)
	REFERENCES [DataObfuscation].[Strategy]
	(
		[StrategyId]
	),
	
	CONSTRAINT [fk_StoredProcedureColumnConfig_Dictionary] FOREIGN KEY
	(
		[DictionaryId]
	)
	REFERENCES [DataObfuscation].[Dictionary]
	(
		[DictionaryId]
	)
)	
GO


CREATE TABLE [DataObfuscation].[TableViewColumnConfig]
(
	[TableViewColumnConfigId] [int] IDENTITY(1,1) NOT NULL,

	[CatalogName] [nvarchar](64) NOT NULL, -- skimping here to prevent index warning exceed 900 bytes
	[SchemaName] [nvarchar](128) NOT NULL,
	[TableName] [nvarchar](128) NOT NULL,
	[ColumnName] [nvarchar](128) NOT NULL,
	
	[StrategyId] [int] NOT NULL,
	
	[DictionaryId] [int] NULL,

	CONSTRAINT [pk_TableViewColumnConfig] PRIMARY KEY
	(
		[TableViewColumnConfigId]
	),
	
	CONSTRAINT [uk_TableViewColumnConfig] UNIQUE
	(
		[CatalogName],
		[SchemaName],
		[TableName],
		[ColumnName]
	),
	
	CONSTRAINT [fk_TableViewColumnConfig_Strategy] FOREIGN KEY
	(
		[StrategyId]
	)
	REFERENCES [DataObfuscation].[Strategy]
	(
		[StrategyId]
	),
	
	CONSTRAINT [fk_TableViewColumnConfig_Dictionary] FOREIGN KEY
	(
		[DictionaryId]
	)
	REFERENCES [DataObfuscation].[Dictionary]
	(
		[DictionaryId]
	)
)	
GO


CREATE FUNCTION [DataObfuscation].[GetHash]
(
	@MULTIPLIER [bigint],
	@HASH_BUCKET_SIZE [int],
	@SEED [bigint],

	@Value [nvarchar](MAX)
)
RETURNS [int]
AS
BEGIN	
	DECLARE @hashcode [bigint]
	DECLARE @MINOR_UPPER_BOUND [bigint]
	DECLARE @MAJOR_UPPER_BOUND [bigint]
	
	SET @MINOR_UPPER_BOUND = 2147483648
	SET @MAJOR_UPPER_BOUND = 4294967296
	
	SET @hashcode = @SEED;
	SELECT @hashcode = (@hashcode * @MULTIPLIER + (SUBSTRING(CAST(@Value AS VARBINARY(MAX)), [BinaryTable].[Index], 1))) % @MAJOR_UPPER_BOUND
		FROM (SELECT TOP(LEN(CAST(@Value AS VARBINARY(MAX)))) ROW_NUMBER() OVER (ORDER BY GETDATE()) AS [Index] FROM sys.all_objects) AS [BinaryTable];
 	
	SET @hashcode =	CASE WHEN @hashcode >= @MINOR_UPPER_BOUND THEN @hashcode - @MAJOR_UPPER_BOUND ELSE @hashcode END;
	SET @hashcode = CASE WHEN @hashcode < 0	THEN @hashcode + @MINOR_UPPER_BOUND ELSE @hashcode END % @HASH_BUCKET_SIZE;
 
	RETURN CAST(@hashcode AS [int])	
END
GO


CREATE FUNCTION [DataObfuscation].[GetHashSubstitution]
(
	@DictionaryId [int],
	
	@Value [nvarchar](MAX)
)
RETURNS [nvarchar](MAX)
AS
BEGIN

	DECLARE @hashMultiplier [bigint]
	DECLARE @hashBucketSize [int]
	DECLARE @hashSeed [bigint]	
	
	DECLARE @dictionaryKey [int]
	DECLARE @dictionaryValue [nvarchar](MAX)
	
	
	SELECT
	@hashMultiplier = [HashMultiplier],
	@hashBucketSize = [HashBucketSize],
	@hashSeed = [HashSeed]
	FROM [DataObfuscation].[Dictionary] t
	WHERE t.[DictionaryId] = @DictionaryId;
	
	SET @dictionaryKey = [DataObfuscation].[GetHash] (@hashMultiplier, @hashBucketSize, @hashSeed, @Value);
	
	SELECT
	@dictionaryValue = t.[Value]
	FROM [DataObfuscation].[Associative] t
	WHERE t.[DictionaryId] = @DictionaryId AND t.[Key] = @dictionaryKey
	
	RETURN @dictionaryValue	
END
GO


INSERT INTO [DataObfuscation].[Strategy] VALUES (0, 'None', 'Performs no obfuscation.');
INSERT INTO [DataObfuscation].[Strategy] VALUES (1, 'Substitution', 'Returns an alternate value for the real data using a hash appoach.');
INSERT INTO [DataObfuscation].[Strategy] VALUES (2, 'Shuffling', 'Returns an alternate value for the real data using a shuffle appoach.');
INSERT INTO [DataObfuscation].[Strategy] VALUES (3, 'Variance', 'Returns a value within +/- (10% | 120d) of the real data');
INSERT INTO [DataObfuscation].[Strategy] VALUES (4, 'Cipher', 'Returns an encrypted value for all real data.');
INSERT INTO [DataObfuscation].[Strategy] VALUES (5, 'Nulling', 'Return a null value instead of the real data.');
INSERT INTO [DataObfuscation].[Strategy] VALUES (6, 'Masking', 'Returns a mask value for most but not all of the real data.');
GO


CREATE FUNCTION [DataObfuscation].[GetObfuscatedTableViewColumnData]
(
	@CatalogName as [nvarchar](64),
	@SchemaName as [nvarchar](128),
	@TableName as [nvarchar](128),
	@ColumnName as [nvarchar](128),
	@Value as [nvarchar](MAX)
)
RETURNS [nvarchar](MAX)
AS
BEGIN

	DECLARE @strategyId [int]
	DECLARE @dictionaryId [int]
	
	SELECT @strategyId = t.[StrategyId], @dictionaryId = t.[DictionaryId]
	FROM [DataObfuscation].[TableViewColumnConfig] t
	WHERE t.[CatalogName] = @CatalogName AND t.[SchemaName] = @SchemaName AND t.[TableName] = @TableName AND t.[ColumnName] = @ColumnName;

	SET @Value = CASE
		WHEN @strategyId IS NULL OR
			@strategyId = 0 THEN @Value
		WHEN @strategyId = 1 THEN [DataObfuscation].[GetHashSubstitution](@dictionaryId, @Value)
		--WHEN @strategyId = 2 THEN @Value
		--WHEN @strategyId = 3 THEN @Value
		WHEN @strategyId = 4 THEN ENCRYPTBYPASSPHRASE('TEXTMETAL', @Value)
		WHEN @strategyId = 5 THEN null
		--WHEN @strategyId = 6 THEN @Value
		ELSE @Value
	END

	RETURN @Value
	
END
GO


]]>

	<ForEach in="Schemas" var-ct="_LoopCount" var-ix="_LoopIndex">
		<ForEach.Filter>
		</ForEach.Filter>
		
		<ForEach.Body>
		
<![CDATA[

CREATE SCHEMA [${SchemaName}]
GO

]]>

			<ForEach in="Tables" var-ct="_LoopCount" var-ix="_LoopIndex">
				<ForEach.Filter>
				</ForEach.Filter>
				<ForEach.Body>
<![CDATA[

CREATE VIEW [${SchemaName}].[${TableName}]
AS

	SELECT
]]>
				<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
					<ForEach.Sort>
						<Ascending>
							<Ascending.Compare>
								<Facet name="ColumnOrdinal" />
							</Ascending.Compare>
						</Ascending>
					</ForEach.Sort>
					<ForEach.Body>
					
<![CDATA[${rb(`
	if ["varchar", "nvarchar"].include?(textMetal.EvaluateToken.invoke("ColumnSqlType"))
		"	[DataObfuscation].[GetObfuscatedTableViewColumnData]('" +
		textMetal.EvaluateToken.invoke("InitialCatalogName") +
		"', '" +
		textMetal.EvaluateToken.invoke("SchemaName") +
		"', '" +
		textMetal.EvaluateToken.invoke("TableName") +
		"', '" +
		textMetal.EvaluateToken.invoke("ColumnName") +
		"', t.[" +
		textMetal.EvaluateToken.invoke("ColumnName") +
		"]) as [" +
		textMetal.EvaluateToken.invoke("ColumnName") +
		"]"
	else
		"	t.[" +	textMetal.EvaluateToken.invoke("ColumnName") + "]"
	end
`)}]]>
							
						<If>
							<If.Condition>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="_LoopCount" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Facet name="_LoopIndex" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</If.Condition>
							<If.True>
<![CDATA[,
]]>
							</If.True>
						</If>
					</ForEach.Body>
				</ForEach>
<![CDATA[
	FROM [${DataObfuscationTargetServerName}].[${InitialCatalogName}].[${SchemaName}].[${TableName}] t

GO
]]>
					
				</ForEach.Body>
			</ForEach>

		</ForEach.Body>
	</ForEach>
	</OutputScope>
</Template>