<?xml version="1.0" encoding="utf-8"?>

<!--
	Copyright ©2002-2014 Daniel Bullington (dpbullington@gmail.com)
	Distributed under the MIT license: http://www.opensource.org/licenses/mit-license.php
-->
<Template xmlns="http://www.textmetal.com/api/v6.0.0">

	<OutputScope name="${ClrNamespace}\Repository.tv.g.cs">
		<Include name="include_gen_cprt_message.cs.txt" />
<![CDATA[

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Linq;
using System.Linq;
using System.Xml;

using TextMetal.Common.Core;
using TextMetal.Common.Data;
using TextMetal.Common.Data.LinqToSql;
]]>
		<If>
			<If.Condition>
				<UnaryExpression operator="IsDef">
					<UnaryExpression.TheExpression>
						<Aspect name="ClrUsingNamespaces" />
					</UnaryExpression.TheExpression>
				</UnaryExpression>
			</If.Condition>
			<If.True>
				<ForEach in="ClrUsingNamespaces" var-ct="_LoopCount" var-ix="_LoopIndex" var-item="_LoopItem">
					<ForEach.Body>
						<![CDATA[using ${_LoopItem};
]]>
					</ForEach.Body>
				</ForEach>
			</If.True>
		</If>

		<If>
			<If.Condition>
				<BinaryExpression operator="Or">
					<BinaryExpression.LeftExpression>
						<BinaryExpression operator="Eq">
							<BinaryExpression.LeftExpression>
								<Facet name="HasTables" />
							</BinaryExpression.LeftExpression>
							<BinaryExpression.RightExpression>
								<Value type="System.Boolean" data="True" />
							</BinaryExpression.RightExpression>
						</BinaryExpression>
					</BinaryExpression.LeftExpression>
					<BinaryExpression.RightExpression>
						<BinaryExpression operator="Eq">
							<BinaryExpression.LeftExpression>
								<Facet name="HasViews" />
							</BinaryExpression.LeftExpression>
							<BinaryExpression.RightExpression>
								<Value type="System.Boolean" data="True" />
							</BinaryExpression.RightExpression>
						</BinaryExpression>
					</BinaryExpression.RightExpression>
				</BinaryExpression>
			</If.Condition>
			<If.True>
				<![CDATA[
]]>
			</If.True>
		</If>

		<If>
			<If.Condition>
				<BinaryExpression operator="Eq">
					<BinaryExpression.LeftExpression>
						<Value type="System.Boolean" data="True" />
					</BinaryExpression.LeftExpression>
					<BinaryExpression.RightExpression>
						<Facet name="HasTables" />
					</BinaryExpression.RightExpression>
				</BinaryExpression>
			</If.Condition>
			<If.True>
				<![CDATA[using ${ClrNamespace}.Tables;
]]>
			</If.True>
		</If>
		<If>
			<If.Condition>
				<BinaryExpression operator="Eq">
					<BinaryExpression.LeftExpression>
						<Value type="System.Boolean" data="True" />
					</BinaryExpression.LeftExpression>
					<BinaryExpression.RightExpression>
						<Facet name="HasViews" />
					</BinaryExpression.RightExpression>
				</BinaryExpression>
			</If.Condition>
			<If.True>
				<![CDATA[using ${ClrNamespace}.Views;
]]>
			</If.True>
		</If>
		<![CDATA[
namespace ${ClrNamespace}
{
	public partial class Repository
	{		
		#region Methods/Operators

]]>

		<ForEach in="Schemas" var-ct="_LoopCount" var-ix="_LoopIndex">			
			<ForEach.Body>
				
				<ForEach in="Tables" var-ct="_LoopCount" var-ix="_LoopIndex">
					<ForEach.Body>
						<![CDATA[		public I${TableNameSingularPascalCase} Load${TableNameSingularPascalCase}(]]>
						<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
							<ForEach.Filter>
								<BinaryExpression operator="Or">
									<BinaryExpression.LeftExpression>
										<BinaryExpression operator="Eq">
											<BinaryExpression.LeftExpression>
												<Facet name="ColumnIsPrimaryKey" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Value type="System.Boolean" data="True" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<BinaryExpression operator="Eq">
											<BinaryExpression.LeftExpression>
												<Facet name="HasNoDefinedPrimaryKeyColumns" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Value type="System.Boolean" data="True" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</ForEach.Filter>
							<ForEach.Body>
								<![CDATA[${ColumnCSharpClrType} @${ColumnNameCamelCase}]]>
								<If>
									<If.Condition>
										<BinaryExpression operator="Ne">
											<BinaryExpression.LeftExpression>
												<Facet name="_LoopCount" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Facet name="_LoopIndex" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</If.Condition>
									<If.True>
										<![CDATA[, ]]>
									</If.True>
								</If>
							</ForEach.Body>
						</ForEach>
						<![CDATA[)
		{
			I${TableNameSingularPascalCase} @${TableNameSingularCamelCase};
			
			if ((object)UnitOfWork.Current == null)
			{
				using (IUnitOfWork unitOfWork = Repository.DefaultUnitOfWorkFactory.Instance.GetUnitOfWork())
				{
					@${TableNameSingularCamelCase} = this.Load${TableNameSingularPascalCase}(unitOfWork, ]]>
						<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
							<ForEach.Filter>
								<BinaryExpression operator="Or">
									<BinaryExpression.LeftExpression>
										<BinaryExpression operator="Eq">
											<BinaryExpression.LeftExpression>
												<Facet name="ColumnIsPrimaryKey" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Value type="System.Boolean" data="True" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<BinaryExpression operator="Eq">
											<BinaryExpression.LeftExpression>
												<Facet name="HasNoDefinedPrimaryKeyColumns" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Value type="System.Boolean" data="True" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</ForEach.Filter>
							<ForEach.Body>
								<![CDATA[@${ColumnNameCamelCase}]]>
								<If>
									<If.Condition>
										<BinaryExpression operator="Ne">
											<BinaryExpression.LeftExpression>
												<Facet name="_LoopCount" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Facet name="_LoopIndex" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</If.Condition>
									<If.True>
										<![CDATA[, ]]>
									</If.True>
								</If>
							</ForEach.Body>
						</ForEach>
						<![CDATA[);

					unitOfWork.Complete();
				}
			}
			else
				@${TableNameSingularCamelCase} = this.Load${TableNameSingularPascalCase}(UnitOfWork.Current, ]]>
						<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
							<ForEach.Filter>
								<BinaryExpression operator="Or">
									<BinaryExpression.LeftExpression>
										<BinaryExpression operator="Eq">
											<BinaryExpression.LeftExpression>
												<Facet name="ColumnIsPrimaryKey" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Value type="System.Boolean" data="True" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<BinaryExpression operator="Eq">
											<BinaryExpression.LeftExpression>
												<Facet name="HasNoDefinedPrimaryKeyColumns" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Value type="System.Boolean" data="True" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</ForEach.Filter>
							<ForEach.Body>
								<![CDATA[@${ColumnNameCamelCase}]]>
								<If>
									<If.Condition>
										<BinaryExpression operator="Ne">
											<BinaryExpression.LeftExpression>
												<Facet name="_LoopCount" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Facet name="_LoopIndex" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</If.Condition>
									<If.True>
										<![CDATA[, ]]>
									</If.True>
								</If>
							</ForEach.Body>
						</ForEach>
						<![CDATA[);
			
			return @${TableNameSingularCamelCase};
		}
		
]]>
				
<![CDATA[		public I${TableNameSingularPascalCase} Load${TableNameSingularPascalCase}(IUnitOfWork unitOfWork, ]]>
						<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
							<ForEach.Filter>
								<BinaryExpression operator="Or">
									<BinaryExpression.LeftExpression>
										<BinaryExpression operator="Eq">
											<BinaryExpression.LeftExpression>
												<Facet name="ColumnIsPrimaryKey" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Value type="System.Boolean" data="True" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<BinaryExpression operator="Eq">
											<BinaryExpression.LeftExpression>
												<Facet name="HasNoDefinedPrimaryKeyColumns" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Value type="System.Boolean" data="True" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</ForEach.Filter>
							<ForEach.Body>
								<![CDATA[${ColumnCSharpClrType} @${ColumnNameCamelCase}]]>
								<If>
									<If.Condition>
										<BinaryExpression operator="Ne">
											<BinaryExpression.LeftExpression>
												<Facet name="_LoopCount" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Facet name="_LoopIndex" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</If.Condition>
									<If.True>
										<![CDATA[, ]]>
									</If.True>
								</If>
							</ForEach.Body>
						</ForEach>
						<![CDATA[)
		{			
			I${TableNameSingularPascalCase} @${TableNameSingularCamelCase};
			${LinqToSqlDataContextRootNamespace}.${TableNameSqlMetalSingularPascalCase} query;
			
			if ((object)unitOfWork == null)
				throw new ArgumentNullException("unitOfWork");
										
			using (AmbientUnitOfWorkAwareDisposableWrapper<${LinqToSqlDataContextRootNamespace}.${LinqToSqlTargetDataContextName}> wrapper = unitOfWork.GetContext<${LinqToSqlDataContextRootNamespace}.${LinqToSqlTargetDataContextName}>())
			{					
				query = wrapper.Disposable.${TableNameSqlMetalPluralPascalCase}.SingleOrDefault(lo => ]]>
					<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
						<ForEach.Filter>
							<BinaryExpression operator="Or">
								<BinaryExpression.LeftExpression>
									<BinaryExpression operator="Eq">
										<BinaryExpression.LeftExpression>
											<Facet name="ColumnIsPrimaryKey" />
										</BinaryExpression.LeftExpression>
										<BinaryExpression.RightExpression>
											<Value type="System.Boolean" data="True" />
										</BinaryExpression.RightExpression>
									</BinaryExpression>
								</BinaryExpression.LeftExpression>
								<BinaryExpression.RightExpression>
									<BinaryExpression operator="Eq">
										<BinaryExpression.LeftExpression>
											<Facet name="HasNoDefinedPrimaryKeyColumns" />
										</BinaryExpression.LeftExpression>
										<BinaryExpression.RightExpression>
											<Value type="System.Boolean" data="True" />
										</BinaryExpression.RightExpression>
									</BinaryExpression>
								</BinaryExpression.RightExpression>
							</BinaryExpression>
						</ForEach.Filter>
						<ForEach.Body>
							
							<If>
								<If.Condition>
									<Ruby src="Script" expr="" file="">
										<Script>
											type = textMetal.EvaluateToken.invoke("ColumnSqlType");
											return ["image", "varbinary", "binary", "rowversion", "timestamp"].include?(type);
										</Script>
									</Ruby>
								</If.Condition>
								<If.True>
									<![CDATA[lo.@${ColumnNameSqlMetalPascalCase}.ToArray() == @${ColumnNameCamelCase}]]>
								</If.True>
								<If.False>
									<If>
										<If.Condition>
											<Ruby src="Script" expr="" file="">
												<Script>
													type = textMetal.EvaluateToken.invoke("ColumnSqlType");
													return ["xml"].include?(type);
												</Script>
											</Ruby>
										</If.Condition>
										<If.True>
											<![CDATA[lo.@${ColumnNameSqlMetalPascalCase} == ToXElement(@${ColumnNameCamelCase})]]>
										</If.True>
										<If.False>
											<![CDATA[lo.@${ColumnNameSqlMetalPascalCase} == @${ColumnNameCamelCase}]]>
										</If.False>
									</If>
								</If.False>
							</If>
							
							<If>
								<If.Condition>
									<BinaryExpression operator="Ne">
										<BinaryExpression.LeftExpression>
											<Facet name="_LoopCount" />
										</BinaryExpression.LeftExpression>
										<BinaryExpression.RightExpression>
											<Facet name="_LoopIndex" />
										</BinaryExpression.RightExpression>
									</BinaryExpression>
								</If.Condition>
								<If.True>
									<![CDATA[ && ]]>
								</If.True>
							</If>
						</ForEach.Body>
					</ForEach>
					<![CDATA[);

				if ((object)query == null)
					return null; // does not exist
				
				@${TableNameSingularCamelCase} = new ${TableNameSingularPascalCase}() /* TODO-FIX */
								{
									// map result to POCO from L2S object
]]>
	<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
		<ForEach.Filter>			
		</ForEach.Filter>
		<ForEach.Body>
<![CDATA[									@${ColumnNamePascalCase} = ]]>	

			<If>
				<If.Condition>
					<Ruby src="Script" expr="" file="">
						<Script>
							type = textMetal.EvaluateToken.invoke("ColumnSqlType");
							return ["image", "varbinary", "binary", "rowversion", "timestamp"].include?(type);
						</Script>
					</Ruby>
				</If.Condition>
				<If.True>
					<![CDATA[(object)query.${ColumnNameSqlMetalPascalCase} != null ? query.@${ColumnNameSqlMetalPascalCase}.ToArray() : null]]>
				</If.True>
				<If.False>
					<If>
						<If.Condition>
							<Ruby src="Script" expr="" file="">
								<Script>
									type = textMetal.EvaluateToken.invoke("ColumnSqlType");
									return ["xml"].include?(type);
								</Script>
							</Ruby>
						</If.Condition>
						<If.True>
							<![CDATA[(object)query.${ColumnNameSqlMetalPascalCase} != null ? ToXmlDocument(query.@${ColumnNameSqlMetalPascalCase}) : null]]>
						</If.True>
						<If.False>
							<![CDATA[query.@${ColumnNameSqlMetalPascalCase}]]>
						</If.False>
					</If>
				</If.False>
			</If>
			
			
			<If>
				<If.Condition>
					<BinaryExpression operator="Ne">
						<BinaryExpression.LeftExpression>
							<Facet name="_LoopCount" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Facet name="_LoopIndex" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</If.Condition>
				<If.True>
<![CDATA[,
]]>
				</If.True>
			</If>
		</ForEach.Body>
	 </ForEach>
<![CDATA[
								};	

				this.OnSelect${TableNameSingularPascalCase}(unitOfWork, @${TableNameSingularCamelCase});

				return @${TableNameSingularCamelCase};
			}
		}
		
		public IEnumerable<I${TableNameSingularPascalCase}> Find${TableNamePluralPascalCase}(Func<IQueryable<${LinqToSqlDataContextRootNamespace}.${TableNameSqlMetalSingularPascalCase}>, IQueryable<${LinqToSqlDataContextRootNamespace}.${TableNameSqlMetalSingularPascalCase}>> callback)
		{
			IEnumerable<I${TableNameSingularPascalCase}> @${TableNamePluralCamelCase};
			
			if ((object)UnitOfWork.Current == null)
			{
				using (IUnitOfWork unitOfWork = Repository.DefaultUnitOfWorkFactory.Instance.GetUnitOfWork())
				{
					@${TableNamePluralCamelCase} = this.Find${TableNamePluralPascalCase}(unitOfWork, callback);

					@${TableNamePluralCamelCase} = @${TableNamePluralCamelCase}.ToList(); // FORCE EAGER LOAD
					
					unitOfWork.Complete();
				}
			}
			else
			{
				@${TableNamePluralCamelCase} = this.Find${TableNamePluralPascalCase}(UnitOfWork.Current, callback);
				
				// DO NOT FORCE EAGER LOAD
			}
			
			return @${TableNamePluralCamelCase};
		}
		
		public IEnumerable<I${TableNameSingularPascalCase}> Find${TableNamePluralPascalCase}(IUnitOfWork unitOfWork, Func<IQueryable<${LinqToSqlDataContextRootNamespace}.${TableNameSqlMetalSingularPascalCase}>, IQueryable<${LinqToSqlDataContextRootNamespace}.${TableNameSqlMetalSingularPascalCase}>> callback)
		{
			IEnumerable<I${TableNameSingularPascalCase}> @${TableNamePluralCamelCase};			
			IQueryable<${LinqToSqlDataContextRootNamespace}.${TableNameSqlMetalSingularPascalCase}> queryable;			
			
			if ((object)unitOfWork == null)		
				throw new ArgumentNullException("unitOfWork");
				
			if ((object)callback == null)
				throw new ArgumentNullException("callback");
				
			using (AmbientUnitOfWorkAwareDisposableWrapper<${LinqToSqlDataContextRootNamespace}.${LinqToSqlTargetDataContextName}> wrapper = unitOfWork.GetContext<${LinqToSqlDataContextRootNamespace}.${LinqToSqlTargetDataContextName}>())
			{
				queryable = callback(wrapper.Disposable.@${TableNameSqlMetalPluralPascalCase});
				
				if ((object)queryable == null)
					throw new InvalidOperationException(string.Format("The queryable returned was invalid."));
				
				@${TableNamePluralCamelCase} = queryable.Select(lo => new ${TableNameSingularPascalCase}() /* TODO-FIX */
												 {
													// map results to POCOs from L2S objects
]]>
	<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
		<ForEach.Filter>			
		</ForEach.Filter>
		<ForEach.Body>
<![CDATA[													@${ColumnNamePascalCase} = ]]>	

			<If>
				<If.Condition>
					<Ruby src="Script" expr="" file="">
						<Script>
							type = textMetal.EvaluateToken.invoke("ColumnSqlType");
							return ["image", "varbinary", "binary", "rowversion", "timestamp"].include?(type);
						</Script>
					</Ruby>
				</If.Condition>
				<If.True>
					<![CDATA[(object)lo.${ColumnNameSqlMetalPascalCase} != null ? lo.@${ColumnNameSqlMetalPascalCase}.ToArray() : null]]>
				</If.True>
				<If.False>
					<If>
						<If.Condition>
							<Ruby src="Script" expr="" file="">
								<Script>
									type = textMetal.EvaluateToken.invoke("ColumnSqlType");
									return ["xml"].include?(type);
								</Script>
							</Ruby>
						</If.Condition>
						<If.True>
							<![CDATA[(object)lo.${ColumnNameSqlMetalPascalCase} != null ? ToXmlDocument(lo.@${ColumnNameSqlMetalPascalCase}) : null]]>
						</If.True>
						<If.False>
							<![CDATA[lo.@${ColumnNameSqlMetalPascalCase}]]>
						</If.False>
					</If>
				</If.False>
			</If>
			
			<If>
				<If.Condition>
					<BinaryExpression operator="Ne">
						<BinaryExpression.LeftExpression>
							<Facet name="_LoopCount" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Facet name="_LoopIndex" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</If.Condition>
				<If.True>
<![CDATA[,
]]>
				</If.True>
			</If>
		</ForEach.Body>
	 </ForEach>
<![CDATA[
												 }); // DOES NOT FORCE EXECUTION AGAINST STORE

				foreach (I${TableNameSingularPascalCase} @${TableNameSingularCamelCase} in @${TableNamePluralCamelCase})
				{
					this.OnSelect${TableNameSingularPascalCase}(unitOfWork, @${TableNameSingularCamelCase});
					
					yield return @${TableNameSingularCamelCase}; // LAZY PROCESSING INTENT HERE / DO NOT FORCE EAGER LOAD
				}				
			}			
		}
		
		public bool Save${TableNameSingularPascalCase}(I${TableNameSingularPascalCase} @${TableNameSingularCamelCase})
		{
			bool retval;

			if ((object)UnitOfWork.Current == null)
			{
				using (IUnitOfWork unitOfWork = Repository.DefaultUnitOfWorkFactory.Instance.GetUnitOfWork())
				{
					retval = this.Save${TableNameSingularPascalCase}(unitOfWork, @${TableNameSingularCamelCase});

					unitOfWork.Complete();
				}
			}
			else
				retval = this.Save${TableNameSingularPascalCase}(UnitOfWork.Current, @${TableNameSingularCamelCase});
			
			return retval;
		}
		
		public bool Save${TableNameSingularPascalCase}(IUnitOfWork unitOfWork, I${TableNameSingularPascalCase} @${TableNameSingularCamelCase})
		{
			${LinqToSqlDataContextRootNamespace}.${TableNameSqlMetalSingularPascalCase} query;
			bool wasNew;
			
			if ((object)unitOfWork == null)
				throw new ArgumentNullException("unitOfWork");
			
			if ((object)@${TableNameSingularCamelCase} == null)
				throw new ArgumentNullException("${TableNameSingularCamelCase}");
				
			using (AmbientUnitOfWorkAwareDisposableWrapper<${LinqToSqlDataContextRootNamespace}.${LinqToSqlTargetDataContextName}> wrapper = unitOfWork.GetContext<${LinqToSqlDataContextRootNamespace}.${LinqToSqlTargetDataContextName}>())
			{
				wasNew = @${TableNameSingularCamelCase}.IsNew;

				if (wasNew)
				{
					this.OnPreInsert${TableNameSingularPascalCase}(unitOfWork, @${TableNameSingularCamelCase});
					
					query = new ${LinqToSqlDataContextRootNamespace}.${TableNameSqlMetalSingularPascalCase}();

					wrapper.Disposable.${TableNameSqlMetalPluralPascalCase}.InsertOnSubmit(query);
				}
				else
				{
					this.OnPreUpdate${TableNameSingularPascalCase}(unitOfWork, @${TableNameSingularCamelCase});
					
					query = wrapper.Disposable.${TableNameSqlMetalPluralPascalCase}.SingleOrDefault(lo => ]]>
						<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
							<ForEach.Filter>
								<BinaryExpression operator="Or">
									<BinaryExpression.LeftExpression>
										<BinaryExpression operator="Eq">
											<BinaryExpression.LeftExpression>
												<Facet name="ColumnIsPrimaryKey" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Value type="System.Boolean" data="True" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<BinaryExpression operator="Eq">
											<BinaryExpression.LeftExpression>
												<Facet name="HasNoDefinedPrimaryKeyColumns" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Value type="System.Boolean" data="True" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</ForEach.Filter>
							<ForEach.Body>
								<If>
									<If.Condition>
										<Ruby src="Script" expr="" file="">
											<Script>
												type = textMetal.EvaluateToken.invoke("ColumnSqlType");
												return ["image", "varbinary", "binary", "rowversion", "timestamp"].include?(type);
											</Script>
										</Ruby>
									</If.Condition>
									<If.True>
										<![CDATA[lo.@${ColumnNameSqlMetalPascalCase}.ToArray() == @${TableNameSingularCamelCase}.@${ColumnNamePascalCase}]]>
									</If.True>
									<If.False>
										<If>
											<If.Condition>
												<Ruby src="Script" expr="" file="">
													<Script>
														type = textMetal.EvaluateToken.invoke("ColumnSqlType");
														return ["xml"].include?(type);
													</Script>
												</Ruby>
											</If.Condition>
											<If.True>
												<![CDATA[lo.@${ColumnNameSqlMetalPascalCase} == ToXElement(@${TableNameSingularCamelCase}.@${ColumnNamePascalCase})]]>
											</If.True>
											<If.False>
												<![CDATA[lo.@${ColumnNameSqlMetalPascalCase} == @${TableNameSingularCamelCase}.@${ColumnNamePascalCase}]]>
											</If.False>
										</If>
									</If.False>
								</If>
								<If>
									<If.Condition>
										<BinaryExpression operator="Ne">
											<BinaryExpression.LeftExpression>
												<Facet name="_LoopCount" />
											</BinaryExpression.LeftExpression>
											<BinaryExpression.RightExpression>
												<Facet name="_LoopIndex" />
											</BinaryExpression.RightExpression>
										</BinaryExpression>
									</If.Condition>
									<If.True>
										<![CDATA[ && ]]>
									</If.True>
								</If>
							</ForEach.Body>
						</ForEach>
						<![CDATA[);

					if((object)query == null)
						throw new InvalidOperationException(string.Format("The queryable returned was invalid."));
				}

				// map caller POCO changes to L2S object
]]>
	<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
		<ForEach.Filter>						
			<BinaryExpression operator="Ne">
				<BinaryExpression.LeftExpression>
					<Facet name="ColumnIsComputed" />
				</BinaryExpression.LeftExpression>
				<BinaryExpression.RightExpression>
					<Value type="System.Boolean" data="True" />
				</BinaryExpression.RightExpression>
			</BinaryExpression>
		</ForEach.Filter>
		<ForEach.Body>
		
			<If>
				<If.Condition>
					<Ruby src="Script" expr="" file="">
						<Script>
							type = textMetal.EvaluateToken.invoke("ColumnSqlType");
							return ["image", "varbinary", "binary", "rowversion", "timestamp"].include?(type);
						</Script>
					</Ruby>
				</If.Condition>
				<If.True>
					<![CDATA[				if ((object)@${TableNameSingularCamelCase}.@${ColumnNamePascalCase} != null) // prevent implicit conversion of null -> exception
					query.@${ColumnNameSqlMetalPascalCase} = @${TableNameSingularCamelCase}.@${ColumnNamePascalCase};]]>
				</If.True>
				<If.False>
					<If>
						<If.Condition>
							<Ruby src="Script" expr="" file="">
								<Script>
									type = textMetal.EvaluateToken.invoke("ColumnSqlType");
									return ["xml"].include?(type);
								</Script>
							</Ruby>
						</If.Condition>
						<If.True>
							<![CDATA[				if ((object)@${TableNameSingularCamelCase}.@${ColumnNamePascalCase} != null) // prevent implicit conversion of null -> exception
					query.@${ColumnNameSqlMetalPascalCase} = ToXElement(@${TableNameSingularCamelCase}.@${ColumnNamePascalCase});]]>
						</If.True>
						<If.False>
							<![CDATA[				query.@${ColumnNameSqlMetalPascalCase} = @${TableNameSingularCamelCase}.@${ColumnNamePascalCase};]]>
						</If.False>
					</If>
				</If.False>
			</If>
			
			<If>
				<If.Condition>
					<BinaryExpression operator="Ne">
						<BinaryExpression.LeftExpression>
							<Facet name="_LoopCount" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Facet name="_LoopIndex" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</If.Condition>
				<If.True>
<![CDATA[
]]>
				</If.True>
			</If>
		</ForEach.Body>
	</ForEach>

<![CDATA[		
				
				try
				{
					wrapper.Disposable.SubmitChanges(ConflictMode.FailOnFirstConflict);
				}
				catch (ChangeConflictException ccex)
				{
					this.OnSaveConflict${TableNameSingularPascalCase}(unitOfWork, @${TableNameSingularCamelCase});
					
					return false;
				}

				// map server changes back to POCO from L2S object
]]>
	<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
		<ForEach.Filter>						
			<!--<BinaryExpression operator="Eq">
				<BinaryExpression.LeftExpression>
					<Facet name="ColumnIsComputed" />
				</BinaryExpression.LeftExpression>
				<BinaryExpression.RightExpression>
					<Value type="System.Boolean" data="True" />
				</BinaryExpression.RightExpression>
			</BinaryExpression>-->
		</ForEach.Filter>
		<ForEach.Body>
			
<![CDATA[				@${TableNameSingularCamelCase}.@${ColumnNamePascalCase} = ]]>
			<If>
				<If.Condition>
					<Ruby src="Script" expr="" file="">
						<Script>
							type = textMetal.EvaluateToken.invoke("ColumnSqlType");
							return ["image", "varbinary", "binary", "rowversion", "timestamp"].include?(type);
						</Script>
					</Ruby>
				</If.Condition>
				<If.True>
					<![CDATA[(object)query.@${ColumnNameSqlMetalPascalCase} != null ? query.@${ColumnNameSqlMetalPascalCase}.ToArray() : null;]]>
				</If.True>
				<If.False>
					<If>
						<If.Condition>
							<Ruby src="Script" expr="" file="">
								<Script>
									type = textMetal.EvaluateToken.invoke("ColumnSqlType");
									return ["xml"].include?(type);
								</Script>
							</Ruby>
						</If.Condition>
						<If.True>
							<![CDATA[(object)query.@${ColumnNameSqlMetalPascalCase} != null ? ToXmlDocument(query.@${ColumnNameSqlMetalPascalCase}) : null;]]>
						</If.True>
						<If.False>
							<![CDATA[query.@${ColumnNameSqlMetalPascalCase};]]>
						</If.False>
					</If>
				</If.False>
			</If>

			
			<If>
				<If.Condition>
					<BinaryExpression operator="Ne">
						<BinaryExpression.LeftExpression>
							<Facet name="_LoopCount" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Facet name="_LoopIndex" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</If.Condition>
				<If.True>
<![CDATA[
]]>
				</If.True>
			</If>
			
			
			<If>
				<If.Condition>
					<BinaryExpression operator="Eq">
						<BinaryExpression.LeftExpression>
							<Facet name="_LoopCount" />
						</BinaryExpression.LeftExpression>
						<BinaryExpression.RightExpression>
							<Facet name="_LoopIndex" />
						</BinaryExpression.RightExpression>
					</BinaryExpression>
				</If.Condition>
				<If.True>
<![CDATA[
]]>
				</If.True>
			</If>
		</ForEach.Body>
	</ForEach>

<![CDATA[						
				if (wasNew)
				{
					this.OnPostInsert${TableNameSingularPascalCase}(unitOfWork, @${TableNameSingularCamelCase});
				}
				else
				{
					this.OnPostUpdate${TableNameSingularPascalCase}(unitOfWork, @${TableNameSingularCamelCase});
				}

				return true;
			}
		}
		
		public bool Discard${TableNameSingularPascalCase}(I${TableNameSingularPascalCase} @${TableNameSingularCamelCase})
		{
			bool retval;
			
			if ((object)UnitOfWork.Current == null)
			{
				using (IUnitOfWork unitOfWork = Repository.DefaultUnitOfWorkFactory.Instance.GetUnitOfWork())
				{
					retval = this.Discard${TableNameSingularPascalCase}(unitOfWork, @${TableNameSingularCamelCase});

					unitOfWork.Complete();
				}
			}
			else
				retval = this.Discard${TableNameSingularPascalCase}(UnitOfWork.Current, @${TableNameSingularCamelCase});
			
			return retval;
		}
		
		public bool Discard${TableNameSingularPascalCase}(IUnitOfWork unitOfWork, I${TableNameSingularPascalCase} @${TableNameSingularCamelCase})
		{
			${LinqToSqlDataContextRootNamespace}.${TableNameSqlMetalSingularPascalCase} query;
			
			if ((object)unitOfWork == null)
				throw new ArgumentNullException("unitOfWork");
			
			if ((object)@${TableNameSingularCamelCase} == null)
				throw new ArgumentNullException("${TableNameSingularCamelCase}");
				
			if (@${TableNameSingularCamelCase}.IsNew)
				return true;
				
			using (AmbientUnitOfWorkAwareDisposableWrapper<${LinqToSqlDataContextRootNamespace}.${LinqToSqlTargetDataContextName}> wrapper = unitOfWork.GetContext<${LinqToSqlDataContextRootNamespace}.${LinqToSqlTargetDataContextName}>())
			{				
				this.OnPreDelete${TableNameSingularPascalCase}(unitOfWork, @${TableNameSingularCamelCase});
				
				query = wrapper.Disposable.@${TableNameSqlMetalPluralPascalCase}.SingleOrDefault(lo => ]]>
					<ForEach in="Columns" var-ct="_LoopCount" var-ix="_LoopIndex">
						<ForEach.Filter>
							<BinaryExpression operator="Or">
								<BinaryExpression.LeftExpression>
									<BinaryExpression operator="Eq">
										<BinaryExpression.LeftExpression>
											<Facet name="ColumnIsPrimaryKey" />
										</BinaryExpression.LeftExpression>
										<BinaryExpression.RightExpression>
											<Value type="System.Boolean" data="True" />
										</BinaryExpression.RightExpression>
									</BinaryExpression>
								</BinaryExpression.LeftExpression>
								<BinaryExpression.RightExpression>
									<BinaryExpression operator="Eq">
										<BinaryExpression.LeftExpression>
											<Facet name="HasNoDefinedPrimaryKeyColumns" />
										</BinaryExpression.LeftExpression>
										<BinaryExpression.RightExpression>
											<Value type="System.Boolean" data="True" />
										</BinaryExpression.RightExpression>
									</BinaryExpression>
								</BinaryExpression.RightExpression>
							</BinaryExpression>
						</ForEach.Filter>
						<ForEach.Body>
							<If>
								<If.Condition>
									<Ruby src="Script" expr="" file="">
										<Script>
											type = textMetal.EvaluateToken.invoke("ColumnSqlType");
											return ["image", "varbinary", "binary", "rowversion", "timestamp"].include?(type);
										</Script>
									</Ruby>
								</If.Condition>
								<If.True>
									<![CDATA[lo.@${ColumnNameSqlMetalPascalCase}.ToArray() == @${TableNameSingularCamelCase}.@${ColumnNamePascalCase}]]>
								</If.True>
								<If.False>
									<If>
										<If.Condition>
											<Ruby src="Script" expr="" file="">
												<Script>
													type = textMetal.EvaluateToken.invoke("ColumnSqlType");
													return ["xml"].include?(type);
												</Script>
											</Ruby>
										</If.Condition>
										<If.True>
											<![CDATA[lo.@${ColumnNameSqlMetalPascalCase} == ToXElement(@${TableNameSingularCamelCase}.@${ColumnNamePascalCase})]]>
										</If.True>
										<If.False>
											<![CDATA[lo.@${ColumnNameSqlMetalPascalCase} == @${TableNameSingularCamelCase}.@${ColumnNamePascalCase}]]>
										</If.False>
									</If>
								</If.False>
							</If>
							<If>
								<If.Condition>
									<BinaryExpression operator="Ne">
										<BinaryExpression.LeftExpression>
											<Facet name="_LoopCount" />
										</BinaryExpression.LeftExpression>
										<BinaryExpression.RightExpression>
											<Facet name="_LoopIndex" />
										</BinaryExpression.RightExpression>
									</BinaryExpression>
								</If.Condition>
								<If.True>
									<![CDATA[ && ]]>
								</If.True>
							</If>
						</ForEach.Body>
					</ForEach>
					<![CDATA[);

				if((object)query == null)
					throw new InvalidOperationException(string.Format("The queryable returned was invalid."));
				
				wrapper.Disposable.@${TableNameSqlMetalPluralPascalCase}.DeleteOnSubmit(query);
				
				try
				{
					wrapper.Disposable.SubmitChanges(ConflictMode.FailOnFirstConflict);
				}
				catch (ChangeConflictException ccex)
				{
					this.OnDiscardConflict${TableNameSingularPascalCase}(unitOfWork, @${TableNameSingularCamelCase});
					
					return false;
				}

				this.OnPostDelete${TableNameSingularPascalCase}(unitOfWork, @${TableNameSingularCamelCase});
				
				@${TableNameSingularCamelCase}.IsNew = false;				

				return true;
			}
		}
		
		partial void OnPreInsert${TableNameSingularPascalCase}(IUnitOfWork unitOfWork, I${TableNameSingularPascalCase} @${TableNameSingularCamelCase});
		
		partial void OnPostInsert${TableNameSingularPascalCase}(IUnitOfWork unitOfWork, I${TableNameSingularPascalCase} @${TableNameSingularCamelCase});
		
		partial void OnPreUpdate${TableNameSingularPascalCase}(IUnitOfWork unitOfWork, I${TableNameSingularPascalCase} @${TableNameSingularCamelCase});
		
		partial void OnPostUpdate${TableNameSingularPascalCase}(IUnitOfWork unitOfWork, I${TableNameSingularPascalCase} @${TableNameSingularCamelCase});
		
		partial void OnPreDelete${TableNameSingularPascalCase}(IUnitOfWork unitOfWork, I${TableNameSingularPascalCase} @${TableNameSingularCamelCase});
		
		partial void OnPostDelete${TableNameSingularPascalCase}(IUnitOfWork unitOfWork, I${TableNameSingularPascalCase} @${TableNameSingularCamelCase});
		
		partial void OnSaveConflict${TableNameSingularPascalCase}(IUnitOfWork unitOfWork, I${TableNameSingularPascalCase} @${TableNameSingularCamelCase});
		
		partial void OnDiscardConflict${TableNameSingularPascalCase}(IUnitOfWork unitOfWork, I${TableNameSingularPascalCase} @${TableNameSingularCamelCase});
		
		partial void OnSelect${TableNameSingularPascalCase}(IUnitOfWork unitOfWork, I${TableNameSingularPascalCase} @${TableNameSingularCamelCase});		
]]>
						<If>
							<If.Condition>
								<BinaryExpression operator="Ne">
									<BinaryExpression.LeftExpression>
										<Facet name="_LoopCount" />
									</BinaryExpression.LeftExpression>
									<BinaryExpression.RightExpression>
										<Facet name="_LoopIndex" />
									</BinaryExpression.RightExpression>
								</BinaryExpression>
							</If.Condition>
							<If.True>
								<![CDATA[
]]>
							</If.True>
						</If>
					</ForEach.Body>
				</ForEach>

			</ForEach.Body>
		</ForEach>

		<![CDATA[
		#endregion
	}
}
]]>
	</OutputScope>

</Template>